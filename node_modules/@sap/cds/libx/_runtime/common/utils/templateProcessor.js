const _formatRowContext = ({ tKey, keyNames, row }) => {
  const keyValuePairs = keyNames.map(key => `${key}=${row[key]}`)
  const keyValuePairsSerialized = keyValuePairs.join(',')
  return `${tKey}(${keyValuePairsSerialized})`
}

const _processElement = args => {
  const { processFn, row, key, elements, picked = {}, complex = false, isRoot, pathOptions } = args
  const { segments: pathSegments } = pathOptions
  const element = elements[key]
  const { plain } = picked

  if (plain) {
    if (!complex && pathSegments) pathSegments.push(key)

    // skip processing if row is undefined, it is not mandatory, and null is allowed
    // where should this go? `if (row && (row[key] !== undefined || element._isMandatory || element.notNull))`
    processFn(row, key, element, plain, isRoot, pathSegments)
  }
}

const _processRow = ({ processFn, row, template, tKey, tValue, isRoot, pathOptions }) => {
  const { template: subTemplate, picked } = tValue
  const key = tKey.split(' ').pop()

  const args = {
    processFn,
    row,
    key,
    elements: template.target.elements,
    picked,
    complex: !!subTemplate,
    isRoot,
    pathOptions
  }
  _processElement(args)

  // process deep
  if (subTemplate) {
    let subRows = row && row[key]
    subRows = Array.isArray(subRows) ? subRows : [subRows]
    const complexArgs = { processFn, rows: subRows, template: subTemplate, tKey: key, pathOptions }
    _processComplex(complexArgs)
  }
}

const _processComplex = ({ processFn, rows, template, tKey, pathOptions }) => {
  if (rows.length === 0) return

  const segments = pathOptions.segments && [...pathOptions.segments]

  let keyNames
  for (const row of rows) {
    if (row == null) continue

    const args = { processFn, row, template, isRoot: false, pathOptions }
    if (pathOptions.includeKeyValues) {
      keyNames = keyNames || (template.target.keys && Object.keys(template.target.keys)) || []
      pathOptions.rowKeysGenerator({ keyNames, row, template })
      const pathSegment = _formatRowContext({ tKey, keyNames, row: { ...row, ...pathOptions.extraKeys } })
      args.pathOptions.segments = segments ? [...segments, pathSegment] : [pathSegment]
    }
    templateProcessor(args)
  }
}

/**
 * @param {import("../../types/api").TemplateProcessor} args
 */
const templateProcessor = ({ processFn, row, template, isRoot = true, pathOptions = {} }) => {
  const segments = pathOptions.segments && [...pathOptions.segments]

  for (const [tKey, tValue] of template.elements) {
    const args = { processFn, row, template, tKey, tValue, isRoot, pathOptions }
    if (segments) args.pathOptions.segments = [...segments]
    _processRow(args)
  }
}

module.exports = templateProcessor
