"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.revertTermToGenericType = exports.convertTypes = exports.defaultReferences = void 0;
var Path = /** @class */ (function () {
    function Path(pathExpression, targetName, annotationsTerm, annotationType, term) {
        this.path = pathExpression.Path;
        this.type = "Path";
        this.$target = targetName;
        (this.term = term), (this.annotationType = annotationType), (this.annotationsTerm = annotationsTerm);
    }
    return Path;
}());
var TermToTypes;
(function (TermToTypes) {
    TermToTypes["Org.OData.Authorization.V1.SecuritySchemes"] = "Org.OData.Authorization.V1.SecurityScheme";
    TermToTypes["Org.OData.Authorization.V1.Authorizations"] = "Org.OData.Authorization.V1.Authorization";
    TermToTypes["Org.OData.Core.V1.Revisions"] = "Org.OData.Core.V1.RevisionType";
    TermToTypes["Org.OData.Core.V1.Links"] = "Org.OData.Core.V1.Link";
    TermToTypes["Org.OData.Core.V1.Example"] = "Org.OData.Core.V1.ExampleValue";
    TermToTypes["Org.OData.Core.V1.Messages"] = "Org.OData.Core.V1.MessageType";
    TermToTypes["Org.OData.Core.V1.ValueException"] = "Org.OData.Core.V1.ValueExceptionType";
    TermToTypes["Org.OData.Core.V1.ResourceException"] = "Org.OData.Core.V1.ResourceExceptionType";
    TermToTypes["Org.OData.Core.V1.DataModificationException"] = "Org.OData.Core.V1.DataModificationExceptionType";
    TermToTypes["Org.OData.Core.V1.IsLanguageDependent"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.DereferenceableIDs"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.ConventionalIDs"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.Permissions"] = "Org.OData.Core.V1.Permission";
    TermToTypes["Org.OData.Core.V1.DefaultNamespace"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.Immutable"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.Computed"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.ComputedDefaultValue"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.IsURL"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.IsMediaType"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.ContentDisposition"] = "Org.OData.Core.V1.ContentDispositionType";
    TermToTypes["Org.OData.Core.V1.OptimisticConcurrency"] = "Edm.PropertyPath";
    TermToTypes["Org.OData.Core.V1.AdditionalProperties"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.AutoExpand"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.AutoExpandReferences"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.MayImplement"] = "Org.OData.Core.V1.QualifiedTypeName";
    TermToTypes["Org.OData.Core.V1.Ordered"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.PositionalInsert"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Core.V1.AlternateKeys"] = "Org.OData.Core.V1.AlternateKey";
    TermToTypes["Org.OData.Core.V1.OptionalParameter"] = "Org.OData.Core.V1.OptionalParameterType";
    TermToTypes["Org.OData.Core.V1.OperationAvailable"] = "Edm.Boolean";
    TermToTypes["Org.OData.Core.V1.SymbolicName"] = "Org.OData.Core.V1.SimpleIdentifier";
    TermToTypes["Org.OData.Capabilities.V1.ConformanceLevel"] = "Org.OData.Capabilities.V1.ConformanceLevelType";
    TermToTypes["Org.OData.Capabilities.V1.AsynchronousRequestsSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.BatchContinueOnErrorSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.IsolationSupported"] = "Org.OData.Capabilities.V1.IsolationLevel";
    TermToTypes["Org.OData.Capabilities.V1.CrossJoinSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.CallbackSupported"] = "Org.OData.Capabilities.V1.CallbackType";
    TermToTypes["Org.OData.Capabilities.V1.ChangeTracking"] = "Org.OData.Capabilities.V1.ChangeTrackingType";
    TermToTypes["Org.OData.Capabilities.V1.CountRestrictions"] = "Org.OData.Capabilities.V1.CountRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.NavigationRestrictions"] = "Org.OData.Capabilities.V1.NavigationRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.IndexableByKey"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.TopSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.SkipSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.ComputeSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.SelectSupport"] = "Org.OData.Capabilities.V1.SelectSupportType";
    TermToTypes["Org.OData.Capabilities.V1.BatchSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.BatchSupport"] = "Org.OData.Capabilities.V1.BatchSupportType";
    TermToTypes["Org.OData.Capabilities.V1.FilterRestrictions"] = "Org.OData.Capabilities.V1.FilterRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.SortRestrictions"] = "Org.OData.Capabilities.V1.SortRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.ExpandRestrictions"] = "Org.OData.Capabilities.V1.ExpandRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.SearchRestrictions"] = "Org.OData.Capabilities.V1.SearchRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.KeyAsSegmentSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.QuerySegmentSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.InsertRestrictions"] = "Org.OData.Capabilities.V1.InsertRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.DeepInsertSupport"] = "Org.OData.Capabilities.V1.DeepInsertSupportType";
    TermToTypes["Org.OData.Capabilities.V1.UpdateRestrictions"] = "Org.OData.Capabilities.V1.UpdateRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.DeepUpdateSupport"] = "Org.OData.Capabilities.V1.DeepUpdateSupportType";
    TermToTypes["Org.OData.Capabilities.V1.DeleteRestrictions"] = "Org.OData.Capabilities.V1.DeleteRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.CollectionPropertyRestrictions"] = "Org.OData.Capabilities.V1.CollectionPropertyRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.OperationRestrictions"] = "Org.OData.Capabilities.V1.OperationRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.AnnotationValuesInQuerySupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Capabilities.V1.ModificationQueryOptions"] = "Org.OData.Capabilities.V1.ModificationQueryOptionsType";
    TermToTypes["Org.OData.Capabilities.V1.ReadRestrictions"] = "Org.OData.Capabilities.V1.ReadRestrictionsType";
    TermToTypes["Org.OData.Capabilities.V1.CustomHeaders"] = "Org.OData.Capabilities.V1.CustomParameter";
    TermToTypes["Org.OData.Capabilities.V1.CustomQueryOptions"] = "Org.OData.Capabilities.V1.CustomParameter";
    TermToTypes["Org.OData.Capabilities.V1.MediaLocationUpdateSupported"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Aggregation.V1.ApplySupported"] = "Org.OData.Aggregation.V1.ApplySupportedType";
    TermToTypes["Org.OData.Aggregation.V1.Groupable"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Aggregation.V1.Aggregatable"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Aggregation.V1.ContextDefiningProperties"] = "Edm.PropertyPath";
    TermToTypes["Org.OData.Aggregation.V1.LeveledHierarchy"] = "Edm.PropertyPath";
    TermToTypes["Org.OData.Aggregation.V1.RecursiveHierarchy"] = "Org.OData.Aggregation.V1.RecursiveHierarchyType";
    TermToTypes["Org.OData.Aggregation.V1.AvailableOnAggregates"] = "Org.OData.Aggregation.V1.AvailableOnAggregatesType";
    TermToTypes["Org.OData.Validation.V1.Minimum"] = "Edm.PrimitiveType";
    TermToTypes["Org.OData.Validation.V1.Maximum"] = "Edm.PrimitiveType";
    TermToTypes["Org.OData.Validation.V1.Exclusive"] = "Org.OData.Core.V1.Tag";
    TermToTypes["Org.OData.Validation.V1.AllowedValues"] = "Org.OData.Validation.V1.AllowedValue";
    TermToTypes["Org.OData.Validation.V1.MultipleOf"] = "Edm.Decimal";
    TermToTypes["Org.OData.Validation.V1.Constraint"] = "Org.OData.Validation.V1.ConstraintType";
    TermToTypes["Org.OData.Validation.V1.ItemsOf"] = "Org.OData.Validation.V1.ItemsOfType";
    TermToTypes["Org.OData.Validation.V1.OpenPropertyTypeConstraint"] = "Org.OData.Core.V1.QualifiedTypeName";
    TermToTypes["Org.OData.Validation.V1.DerivedTypeConstraint"] = "Org.OData.Core.V1.QualifiedTypeName";
    TermToTypes["Org.OData.Validation.V1.AllowedTerms"] = "Org.OData.Core.V1.QualifiedTermName";
    TermToTypes["Org.OData.Validation.V1.ApplicableTerms"] = "Org.OData.Core.V1.QualifiedTermName";
    TermToTypes["Org.OData.Validation.V1.MaxItems"] = "Edm.Int64";
    TermToTypes["Org.OData.Validation.V1.MinItems"] = "Edm.Int64";
    TermToTypes["Org.OData.Measures.V1.Scale"] = "Edm.Byte";
    TermToTypes["Org.OData.Measures.V1.DurationGranularity"] = "Org.OData.Measures.V1.DurationGranularityType";
    TermToTypes["com.sap.vocabularies.Analytics.v1.Dimension"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Analytics.v1.Measure"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Analytics.v1.AccumulativeMeasure"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Analytics.v1.RolledUpPropertyCount"] = "Edm.Int16";
    TermToTypes["com.sap.vocabularies.Analytics.v1.PlanningAction"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Analytics.v1.AggregatedProperties"] = "com.sap.vocabularies.Analytics.v1.AggregatedPropertyType";
    TermToTypes["com.sap.vocabularies.Common.v1.ServiceVersion"] = "Edm.Int32";
    TermToTypes["com.sap.vocabularies.Common.v1.ServiceSchemaVersion"] = "Edm.Int32";
    TermToTypes["com.sap.vocabularies.Common.v1.TextFor"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.Common.v1.IsLanguageIdentifier"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.TextFormat"] = "com.sap.vocabularies.Common.v1.TextFormatType";
    TermToTypes["com.sap.vocabularies.Common.v1.IsDigitSequence"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsUpperCase"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCurrency"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsUnit"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.UnitSpecificScale"] = "Edm.PrimitiveType";
    TermToTypes["com.sap.vocabularies.Common.v1.UnitSpecificPrecision"] = "Edm.PrimitiveType";
    TermToTypes["com.sap.vocabularies.Common.v1.SecondaryKey"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.Common.v1.MinOccurs"] = "Edm.Int64";
    TermToTypes["com.sap.vocabularies.Common.v1.MaxOccurs"] = "Edm.Int64";
    TermToTypes["com.sap.vocabularies.Common.v1.AssociationEntity"] = "Edm.NavigationPropertyPath";
    TermToTypes["com.sap.vocabularies.Common.v1.DerivedNavigation"] = "Edm.NavigationPropertyPath";
    TermToTypes["com.sap.vocabularies.Common.v1.Masked"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.MaskedAlways"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.SemanticObjectMapping"] = "com.sap.vocabularies.Common.v1.SemanticObjectMappingType";
    TermToTypes["com.sap.vocabularies.Common.v1.IsInstanceAnnotation"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.FilterExpressionRestrictions"] = "com.sap.vocabularies.Common.v1.FilterExpressionRestrictionType";
    TermToTypes["com.sap.vocabularies.Common.v1.FieldControl"] = "com.sap.vocabularies.Common.v1.FieldControlType";
    TermToTypes["com.sap.vocabularies.Common.v1.Application"] = "com.sap.vocabularies.Common.v1.ApplicationType";
    TermToTypes["com.sap.vocabularies.Common.v1.Timestamp"] = "Edm.DateTimeOffset";
    TermToTypes["com.sap.vocabularies.Common.v1.ErrorResolution"] = "com.sap.vocabularies.Common.v1.ErrorResolutionType";
    TermToTypes["com.sap.vocabularies.Common.v1.Messages"] = "Edm.ComplexType";
    TermToTypes["com.sap.vocabularies.Common.v1.numericSeverity"] = "com.sap.vocabularies.Common.v1.NumericMessageSeverityType";
    TermToTypes["com.sap.vocabularies.Common.v1.MaximumNumericMessageSeverity"] = "com.sap.vocabularies.Common.v1.NumericMessageSeverityType";
    TermToTypes["com.sap.vocabularies.Common.v1.IsActionCritical"] = "Edm.Boolean";
    TermToTypes["com.sap.vocabularies.Common.v1.Attributes"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.Common.v1.RelatedRecursiveHierarchy"] = "Edm.AnnotationPath";
    TermToTypes["com.sap.vocabularies.Common.v1.Interval"] = "com.sap.vocabularies.Common.v1.IntervalType";
    TermToTypes["com.sap.vocabularies.Common.v1.ResultContext"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.WeakReferentialConstraint"] = "com.sap.vocabularies.Common.v1.WeakReferentialConstraintType";
    TermToTypes["com.sap.vocabularies.Common.v1.IsNaturalPerson"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.ValueList"] = "com.sap.vocabularies.Common.v1.ValueListType";
    TermToTypes["com.sap.vocabularies.Common.v1.ValueListRelevantQualifiers"] = "com.sap.vocabularies.Common.v1.SimpleIdentifier";
    TermToTypes["com.sap.vocabularies.Common.v1.ValueListWithFixedValues"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.ValueListMapping"] = "com.sap.vocabularies.Common.v1.ValueListMappingType";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarYear"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarHalfyear"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarQuarter"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarMonth"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarWeek"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsDayOfCalendarMonth"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsDayOfCalendarYear"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarYearHalfyear"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarYearQuarter"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarYearMonth"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarYearWeek"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsCalendarDate"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsFiscalYear"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsFiscalPeriod"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsFiscalYearPeriod"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsFiscalQuarter"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsFiscalYearQuarter"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsFiscalWeek"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsFiscalYearWeek"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsDayOfFiscalYear"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.IsFiscalYearVariant"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.MutuallyExclusiveTerm"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Common.v1.DraftRoot"] = "com.sap.vocabularies.Common.v1.DraftRootType";
    TermToTypes["com.sap.vocabularies.Common.v1.DraftNode"] = "com.sap.vocabularies.Common.v1.DraftNodeType";
    TermToTypes["com.sap.vocabularies.Common.v1.DraftActivationVia"] = "com.sap.vocabularies.Common.v1.SimpleIdentifier";
    TermToTypes["com.sap.vocabularies.Common.v1.EditableFieldFor"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.Common.v1.SemanticKey"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.Common.v1.SideEffects"] = "com.sap.vocabularies.Common.v1.SideEffectsType";
    TermToTypes["com.sap.vocabularies.Common.v1.DefaultValuesFunction"] = "com.sap.vocabularies.Common.v1.QualifiedName";
    TermToTypes["com.sap.vocabularies.Common.v1.FilterDefaultValue"] = "Edm.PrimitiveType";
    TermToTypes["com.sap.vocabularies.Common.v1.FilterDefaultValueHigh"] = "Edm.PrimitiveType";
    TermToTypes["com.sap.vocabularies.Common.v1.SortOrder"] = "com.sap.vocabularies.Common.v1.SortOrderType";
    TermToTypes["com.sap.vocabularies.Common.v1.RecursiveHierarchy"] = "com.sap.vocabularies.Common.v1.RecursiveHierarchyType";
    TermToTypes["com.sap.vocabularies.Common.v1.CreatedAt"] = "Edm.DateTimeOffset";
    TermToTypes["com.sap.vocabularies.Common.v1.CreatedBy"] = "com.sap.vocabularies.Common.v1.UserID";
    TermToTypes["com.sap.vocabularies.Common.v1.ChangedAt"] = "Edm.DateTimeOffset";
    TermToTypes["com.sap.vocabularies.Common.v1.ChangedBy"] = "com.sap.vocabularies.Common.v1.UserID";
    TermToTypes["com.sap.vocabularies.Common.v1.ApplyMultiUnitBehaviorForSortingAndFiltering"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.CodeList.v1.CurrencyCodes"] = "com.sap.vocabularies.CodeList.v1.CodeListSource";
    TermToTypes["com.sap.vocabularies.CodeList.v1.UnitsOfMeasure"] = "com.sap.vocabularies.CodeList.v1.CodeListSource";
    TermToTypes["com.sap.vocabularies.CodeList.v1.StandardCode"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.CodeList.v1.ExternalCode"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.CodeList.v1.IsConfigurationDeprecationCode"] = "Edm.Boolean";
    TermToTypes["com.sap.vocabularies.Communication.v1.Contact"] = "com.sap.vocabularies.Communication.v1.ContactType";
    TermToTypes["com.sap.vocabularies.Communication.v1.Address"] = "com.sap.vocabularies.Communication.v1.AddressType";
    TermToTypes["com.sap.vocabularies.Communication.v1.IsEmailAddress"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Communication.v1.IsPhoneNumber"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Communication.v1.Event"] = "com.sap.vocabularies.Communication.v1.EventData";
    TermToTypes["com.sap.vocabularies.Communication.v1.Task"] = "com.sap.vocabularies.Communication.v1.TaskData";
    TermToTypes["com.sap.vocabularies.Communication.v1.Message"] = "com.sap.vocabularies.Communication.v1.MessageData";
    TermToTypes["com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchy"] = "com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchyType";
    TermToTypes["com.sap.vocabularies.PersonalData.v1.EntitySemantics"] = "com.sap.vocabularies.PersonalData.v1.EntitySemanticsType";
    TermToTypes["com.sap.vocabularies.PersonalData.v1.FieldSemantics"] = "com.sap.vocabularies.PersonalData.v1.FieldSemanticsType";
    TermToTypes["com.sap.vocabularies.PersonalData.v1.IsPotentiallyPersonal"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.PersonalData.v1.IsPotentiallySensitive"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.Session.v1.StickySessionSupported"] = "com.sap.vocabularies.Session.v1.StickySessionSupportedType";
    TermToTypes["com.sap.vocabularies.UI.v1.HeaderInfo"] = "com.sap.vocabularies.UI.v1.HeaderInfoType";
    TermToTypes["com.sap.vocabularies.UI.v1.Identification"] = "com.sap.vocabularies.UI.v1.DataFieldAbstract";
    TermToTypes["com.sap.vocabularies.UI.v1.Badge"] = "com.sap.vocabularies.UI.v1.BadgeType";
    TermToTypes["com.sap.vocabularies.UI.v1.LineItem"] = "com.sap.vocabularies.UI.v1.DataFieldAbstract";
    TermToTypes["com.sap.vocabularies.UI.v1.StatusInfo"] = "com.sap.vocabularies.UI.v1.DataFieldAbstract";
    TermToTypes["com.sap.vocabularies.UI.v1.FieldGroup"] = "com.sap.vocabularies.UI.v1.FieldGroupType";
    TermToTypes["com.sap.vocabularies.UI.v1.ConnectedFields"] = "com.sap.vocabularies.UI.v1.ConnectedFieldsType";
    TermToTypes["com.sap.vocabularies.UI.v1.GeoLocations"] = "com.sap.vocabularies.UI.v1.GeoLocationType";
    TermToTypes["com.sap.vocabularies.UI.v1.GeoLocation"] = "com.sap.vocabularies.UI.v1.GeoLocationType";
    TermToTypes["com.sap.vocabularies.UI.v1.Contacts"] = "Edm.AnnotationPath";
    TermToTypes["com.sap.vocabularies.UI.v1.MediaResource"] = "com.sap.vocabularies.UI.v1.MediaResourceType";
    TermToTypes["com.sap.vocabularies.UI.v1.DataPoint"] = "com.sap.vocabularies.UI.v1.DataPointType";
    TermToTypes["com.sap.vocabularies.UI.v1.KPI"] = "com.sap.vocabularies.UI.v1.KPIType";
    TermToTypes["com.sap.vocabularies.UI.v1.Chart"] = "com.sap.vocabularies.UI.v1.ChartDefinitionType";
    TermToTypes["com.sap.vocabularies.UI.v1.ValueCriticality"] = "com.sap.vocabularies.UI.v1.ValueCriticalityType";
    TermToTypes["com.sap.vocabularies.UI.v1.CriticalityLabels"] = "com.sap.vocabularies.UI.v1.CriticalityLabelType";
    TermToTypes["com.sap.vocabularies.UI.v1.SelectionFields"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.UI.v1.Facets"] = "com.sap.vocabularies.UI.v1.Facet";
    TermToTypes["com.sap.vocabularies.UI.v1.HeaderFacets"] = "com.sap.vocabularies.UI.v1.Facet";
    TermToTypes["com.sap.vocabularies.UI.v1.QuickViewFacets"] = "com.sap.vocabularies.UI.v1.Facet";
    TermToTypes["com.sap.vocabularies.UI.v1.QuickCreateFacets"] = "com.sap.vocabularies.UI.v1.Facet";
    TermToTypes["com.sap.vocabularies.UI.v1.FilterFacets"] = "com.sap.vocabularies.UI.v1.ReferenceFacet";
    TermToTypes["com.sap.vocabularies.UI.v1.SelectionPresentationVariant"] = "com.sap.vocabularies.UI.v1.SelectionPresentationVariantType";
    TermToTypes["com.sap.vocabularies.UI.v1.PresentationVariant"] = "com.sap.vocabularies.UI.v1.PresentationVariantType";
    TermToTypes["com.sap.vocabularies.UI.v1.SelectionVariant"] = "com.sap.vocabularies.UI.v1.SelectionVariantType";
    TermToTypes["com.sap.vocabularies.UI.v1.ThingPerspective"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.IsSummary"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.PartOfPreview"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.Map"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.Gallery"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.IsImageURL"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.IsImage"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.MultiLineText"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.TextArrangement"] = "com.sap.vocabularies.UI.v1.TextArrangementType";
    TermToTypes["com.sap.vocabularies.UI.v1.Importance"] = "com.sap.vocabularies.UI.v1.ImportanceType";
    TermToTypes["com.sap.vocabularies.UI.v1.Hidden"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.CreateHidden"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.UpdateHidden"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.DeleteHidden"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.HiddenFilter"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.DataFieldDefault"] = "com.sap.vocabularies.UI.v1.DataFieldAbstract";
    TermToTypes["com.sap.vocabularies.UI.v1.Criticality"] = "com.sap.vocabularies.UI.v1.CriticalityType";
    TermToTypes["com.sap.vocabularies.UI.v1.CriticalityCalculation"] = "com.sap.vocabularies.UI.v1.CriticalityCalculationType";
    TermToTypes["com.sap.vocabularies.UI.v1.Emphasized"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.UI.v1.OrderBy"] = "Edm.PropertyPath";
    TermToTypes["com.sap.vocabularies.UI.v1.ParameterDefaultValue"] = "Edm.PrimitiveType";
    TermToTypes["com.sap.vocabularies.UI.v1.RecommendationState"] = "com.sap.vocabularies.UI.v1.RecommendationStateType";
    TermToTypes["com.sap.vocabularies.UI.v1.RecommendationList"] = "com.sap.vocabularies.UI.v1.RecommendationListType";
    TermToTypes["com.sap.vocabularies.UI.v1.ExcludeFromNavigationContext"] = "Org.OData.Core.V1.Tag";
    TermToTypes["com.sap.vocabularies.HTML5.v1.CssDefaults"] = "com.sap.vocabularies.HTML5.v1.CssDefaultsType";
})(TermToTypes || (TermToTypes = {}));
exports.defaultReferences = [
    { alias: "Capabilities", namespace: "Org.OData.Capabilities.V1", uri: "" },
    { alias: "Aggregation", namespace: "Org.OData.Aggregation.V1", uri: "" },
    { alias: "Validation", namespace: "Org.OData.Validation.V1", uri: "" },
    { namespace: "Org.OData.Core.V1", alias: "Core", uri: "" },
    { namespace: "Org.OData.Measures.V1", alias: "Measures", uri: "" },
    { namespace: "com.sap.vocabularies.Common.v1", alias: "Common", uri: "" },
    { namespace: "com.sap.vocabularies.UI.v1", alias: "UI", uri: "" },
    { namespace: "com.sap.vocabularies.Session.v1", alias: "Session", uri: "" },
    { namespace: "com.sap.vocabularies.Analytics.v1", alias: "Analytics", uri: "" },
    { namespace: "com.sap.vocabularies.CodeList.v1", alias: "CodeList", uri: "" },
    { namespace: "com.sap.vocabularies.PersonalData.v1", alias: "PersonalData", uri: "" },
    { namespace: "com.sap.vocabularies.Communication.v1", alias: "Communication", uri: "" },
    { namespace: "com.sap.vocabularies.HTML5.v1", alias: "HTML5", uri: "" }
];
function alias(references, unaliasedValue) {
    if (!references.reverseReferenceMap) {
        references.reverseReferenceMap = references.reduce(function (map, reference) {
            map[reference.namespace] = reference;
            return map;
        }, {});
    }
    if (!unaliasedValue) {
        return unaliasedValue;
    }
    var lastDotIndex = unaliasedValue.lastIndexOf(".");
    var namespace = unaliasedValue.substr(0, lastDotIndex);
    var value = unaliasedValue.substr(lastDotIndex + 1);
    var reference = references.reverseReferenceMap[namespace];
    if (reference) {
        return reference.alias + "." + value;
    }
    else {
        // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
        if (unaliasedValue.indexOf("@") !== -1) {
            var _a = unaliasedValue.split("@"), preAlias = _a[0], postAlias = _a.slice(1);
            return preAlias + "@" + alias(references, postAlias.join("@"));
        }
        else {
            return unaliasedValue;
        }
    }
}
function unalias(references, aliasedValue) {
    if (!references.referenceMap) {
        references.referenceMap = references.reduce(function (map, reference) {
            map[reference.alias] = reference;
            return map;
        }, {});
    }
    if (!aliasedValue) {
        return aliasedValue;
    }
    var _a = aliasedValue.split("."), alias = _a[0], value = _a.slice(1);
    var reference = references.referenceMap[alias];
    if (reference) {
        return reference.namespace + "." + value.join(".");
    }
    else {
        // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
        if (aliasedValue.indexOf("@") !== -1) {
            var _b = aliasedValue.split("@"), preAlias = _b[0], postAlias = _b.slice(1);
            return preAlias + "@" + unalias(references, postAlias.join("@"));
        }
        else {
            return aliasedValue;
        }
    }
}
function buildObjectMap(parserOutput) {
    var objectMap = {};
    if (parserOutput.schema.entityContainer && parserOutput.schema.entityContainer.fullyQualifiedName) {
        objectMap[parserOutput.schema.entityContainer.fullyQualifiedName] = parserOutput.schema.entityContainer;
    }
    parserOutput.schema.entitySets.forEach(function (entitySet) {
        objectMap[entitySet.fullyQualifiedName] = entitySet;
    });
    parserOutput.schema.actions.forEach(function (action) {
        objectMap[action.fullyQualifiedName] = action;
        objectMap[action.fullyQualifiedName.split("(")[0]] = action;
        action.parameters.forEach(function (parameter) {
            objectMap[parameter.fullyQualifiedName] = parameter;
        });
    });
    parserOutput.schema.complexTypes.forEach(function (complexType) {
        objectMap[complexType.fullyQualifiedName] = complexType;
        complexType.properties.forEach(function (property) {
            objectMap[property.fullyQualifiedName] = property;
        });
    });
    parserOutput.schema.entityTypes.forEach(function (entityType) {
        objectMap[entityType.fullyQualifiedName] = entityType;
        entityType.entityProperties.forEach(function (property) {
            objectMap[property.fullyQualifiedName] = property;
            if (property.type.indexOf("Edm") === -1) {
                // Handle complex types
                var complexTypeDefinition = objectMap[property.type];
                if (complexTypeDefinition && complexTypeDefinition.properties) {
                    complexTypeDefinition.properties.forEach(function (complexTypeProp) {
                        var complexTypePropTarget = Object.assign(complexTypeProp, {
                            _type: "Property",
                            fullyQualifiedName: property.fullyQualifiedName + "/" + complexTypeProp.name
                        });
                        objectMap[complexTypePropTarget.fullyQualifiedName] = complexTypePropTarget;
                    });
                }
            }
        });
        entityType.navigationProperties.forEach(function (navProperty) {
            objectMap[navProperty.fullyQualifiedName] = navProperty;
        });
    });
    Object.keys(parserOutput.schema.annotations).forEach(function (annotationSource) {
        parserOutput.schema.annotations[annotationSource].forEach(function (annotationList) {
            var currentTargetName = unalias(parserOutput.references, annotationList.target);
            annotationList.annotations.forEach(function (annotation) {
                var annotationFQN = currentTargetName + "@" + unalias(parserOutput.references, annotation.term);
                if (annotation.qualifier) {
                    annotationFQN += "#" + annotation.qualifier;
                }
                if (typeof annotation !== "object") {
                    debugger;
                }
                objectMap[annotationFQN] = annotation;
                annotation.fullyQualifiedName = annotationFQN;
            });
        });
    });
    return objectMap;
}
function combinePath(currentTarget, path) {
    if (path.startsWith("@")) {
        return currentTarget + unalias(exports.defaultReferences, path);
    }
    else {
        return currentTarget + "/" + path;
    }
}
function addAnnotationErrorMessage(path, oErrorMsg) {
    if (!ALL_ANNOTATION_ERRORS[path]) {
        ALL_ANNOTATION_ERRORS[path] = [oErrorMsg];
    }
    else {
        ALL_ANNOTATION_ERRORS[path].push(oErrorMsg);
    }
}
function resolveTarget(objectMap, currentTarget, path, pathOnly, includeVisitedObjects, annotationType, annotationsTerm) {
    if (pathOnly === void 0) { pathOnly = false; }
    if (includeVisitedObjects === void 0) { includeVisitedObjects = false; }
    if (!path) {
        return undefined;
    }
    //const propertyPath = path;
    var aVisitedObjects = [];
    if (currentTarget && currentTarget._type === "Property") {
        currentTarget = objectMap[currentTarget.fullyQualifiedName.split("/")[0]];
    }
    path = combinePath(currentTarget.fullyQualifiedName, path);
    var pathSplit = path.split("/");
    var targetPathSplit = [];
    pathSplit.forEach(function (pathPart) {
        // Separate out the annotation
        if (pathPart.indexOf("@") !== -1) {
            var _a = pathPart.split("@"), path_1 = _a[0], annotationPath = _a[1];
            targetPathSplit.push(path_1);
            targetPathSplit.push("@" + annotationPath);
        }
        else {
            targetPathSplit.push(pathPart);
        }
    });
    var currentPath = path;
    var target = targetPathSplit.reduce(function (currentValue, pathPart) {
        if (pathPart === "$Type" && currentValue._type === "EntityType") {
            return currentValue;
        }
        if (pathPart.length === 0) {
            // Empty Path after an entitySet means entityType
            if (currentValue && currentValue._type === "EntitySet" && currentValue.entityType) {
                aVisitedObjects.push(currentValue);
                currentValue = currentValue.entityType;
            }
            if (currentValue && currentValue._type === "NavigationProperty" && currentValue.targetType) {
                aVisitedObjects.push(currentValue);
                currentValue = currentValue.targetType;
            }
            return currentValue;
        }
        if (includeVisitedObjects && currentValue !== null && currentValue !== undefined) {
            aVisitedObjects.push(currentValue);
        }
        if (!currentValue) {
            currentPath = pathPart;
        }
        else if (currentValue._type === "EntitySet" && pathPart === "$Type") {
            currentValue = currentValue.targetType;
            return currentValue;
        }
        else if (currentValue._type === "EntitySet" && currentValue.entityType) {
            currentPath = combinePath(currentValue.entityTypeName, pathPart);
        }
        else if (currentValue._type === "NavigationProperty" && currentValue.targetTypeName) {
            currentPath = combinePath(currentValue.targetTypeName, pathPart);
        }
        else if (currentValue._type === "NavigationProperty" && currentValue.targetType) {
            currentPath = combinePath(currentValue.targetType.fullyQualifiedName, pathPart);
        }
        else if (currentValue._type === "Property") {
            // ComplexType or Property
            if (currentValue.targetType) {
                currentPath = combinePath(currentValue.targetType.fullyQualifiedName, pathPart);
            }
            else {
                currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
            }
        }
        else if (currentValue._type === "Action" && currentValue.isBound) {
            currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
            if (!objectMap[currentPath]) {
                currentPath = combinePath(currentValue.sourceType, pathPart);
            }
        }
        else if (currentValue._type === "ActionParameter" && currentValue.isEntitySet) {
            currentPath = combinePath(currentValue.type, pathPart);
        }
        else if (currentValue._type === "ActionParameter" && !currentValue.isEntitySet) {
            currentPath = combinePath(currentTarget.fullyQualifiedName.substr(0, currentTarget.fullyQualifiedName.lastIndexOf("/")), pathPart);
            if (!objectMap[currentPath]) {
                var lastIdx = currentTarget.fullyQualifiedName.lastIndexOf("/");
                if (lastIdx === -1) {
                    lastIdx = currentTarget.fullyQualifiedName.length;
                }
                currentPath = combinePath(objectMap[currentTarget.fullyQualifiedName.substr(0, lastIdx)].sourceType, pathPart);
            }
        }
        else {
            currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
            if (pathPart !== "name" && currentValue[pathPart] !== undefined) {
                return currentValue[pathPart];
            }
            else if (pathPart === "$AnnotationPath" && currentValue.$target) {
                var currentContext = objectMap[currentValue.fullyQualifiedName.split("@")[0]];
                var subTarget = resolveTarget(objectMap, currentContext, currentValue.value, false, true);
                aVisitedObjects = aVisitedObjects.concat(subTarget.visitedObjects.slice(1));
                return subTarget.target;
            }
            else if (pathPart === "$Path" && currentValue.$target) {
                return currentValue.$target;
            }
            else if (pathPart.startsWith("$Path") && currentValue.$target) {
                var intermediateTarget = currentValue.$target;
                currentPath = combinePath(intermediateTarget.fullyQualifiedName, pathPart.substr(5));
            }
            else if (currentValue.hasOwnProperty("$Type") && !objectMap[currentPath]) {
                // This is now an annotation value
                var entityType = objectMap[currentValue.fullyQualifiedName.split("@")[0]];
                if (entityType) {
                    currentPath = combinePath(entityType.fullyQualifiedName, pathPart);
                }
            }
        }
        return objectMap[currentPath];
    }, null);
    if (!target) {
        if (annotationsTerm && annotationType) {
            var oErrorMsg = {
                message: "Unable to resolve the path expression: " +
                    "\n" +
                    path +
                    "\n" +
                    "\n" +
                    "Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n" +
                    "<Annotation Term = " +
                    annotationsTerm +
                    ">" +
                    "\n" +
                    "<Record Type = " +
                    annotationType +
                    ">" +
                    "\n" +
                    "<AnnotationPath = " +
                    path +
                    ">"
            };
            addAnnotationErrorMessage(path, oErrorMsg);
        }
        else {
            var oErrorMsg = {
                message: "Unable to resolve the path expression: " +
                    path +
                    "\n" +
                    "\n" +
                    "Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n" +
                    "<Annotation Term = " +
                    pathSplit[0] +
                    ">" +
                    "\n" +
                    "<PropertyValue  Path= " +
                    pathSplit[1] +
                    ">"
            };
            addAnnotationErrorMessage(path, oErrorMsg);
        }
        // console.log("Missing target " + path);
    }
    if (pathOnly) {
        return currentPath;
    }
    if (includeVisitedObjects) {
        return {
            visitedObjects: aVisitedObjects,
            target: target
        };
    }
    return target;
}
function isAnnotationPath(pathStr) {
    return pathStr.indexOf("@") !== -1;
}
function parseValue(propertyValue, valueFQN, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, annotationType, annotationsTerm) {
    if (propertyValue === undefined) {
        return undefined;
    }
    switch (propertyValue.type) {
        case "String":
            return propertyValue.String;
        case "Int":
            return propertyValue.Int;
        case "Bool":
            return propertyValue.Bool;
        case "Decimal":
            return propertyValue.Decimal;
        case "Date":
            return propertyValue.Date;
        case "EnumMember":
            return alias(parserOutput.references, propertyValue.EnumMember);
        case "PropertyPath":
            return {
                type: "PropertyPath",
                value: propertyValue.PropertyPath,
                fullyQualifiedName: valueFQN,
                $target: resolveTarget(objectMap, currentTarget, propertyValue.PropertyPath, false, false, annotationType, annotationsTerm)
            };
        case "NavigationPropertyPath":
            return {
                type: "NavigationPropertyPath",
                value: propertyValue.NavigationPropertyPath,
                fullyQualifiedName: valueFQN,
                $target: resolveTarget(objectMap, currentTarget, propertyValue.NavigationPropertyPath, false, false, annotationType, annotationsTerm)
            };
        case "AnnotationPath":
            var annotationTarget = resolveTarget(objectMap, currentTarget, unalias(parserOutput.references, propertyValue.AnnotationPath), true, false, annotationType, annotationsTerm);
            var annotationPath = {
                type: "AnnotationPath",
                value: propertyValue.AnnotationPath,
                fullyQualifiedName: valueFQN,
                $target: annotationTarget,
                annotationType: annotationType,
                annotationsTerm: annotationsTerm,
                term: "",
                path: ""
            };
            toResolve.push({ inline: false, toResolve: annotationPath });
            return annotationPath;
        case "Path":
            var $target = resolveTarget(objectMap, currentTarget, propertyValue.Path, true, false, annotationType, annotationsTerm);
            var path = new Path(propertyValue, $target, annotationsTerm, annotationType, "");
            toResolve.push({
                inline: isAnnotationPath(propertyValue.Path),
                toResolve: path
            });
            return path;
        case "Record":
            return parseRecord(propertyValue.Record, valueFQN, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, annotationType, annotationsTerm);
        case "Collection":
            return parseCollection(propertyValue.Collection, valueFQN, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, annotationType, annotationsTerm);
        case "Apply":
        case "Not":
        case "Eq":
        case "Ne":
        case "Gt":
        case "Ge":
        case "Lt":
        case "Le":
        case "If":
        case "And":
        case "Or":
            return propertyValue;
    }
}
function inferTypeFromTerm(annotationsTerm, parserOutput, annotationTarget) {
    var targetType = TermToTypes[annotationsTerm];
    var oErrorMsg = {
        isError: false,
        message: "The type of the record used within the term " + annotationsTerm + " was not defined and was inferred as " + targetType + ".\nHint: If possible, try to maintain the Type property for each Record.\n<Annotations Target=\"" + annotationTarget + "\">\n\t<Annotation Term=\"" + annotationsTerm + "\">\n\t\t<Record>...</Record>\n\t</Annotation>\n</Annotations>"
    };
    addAnnotationErrorMessage(annotationTarget + "/" + annotationsTerm, oErrorMsg);
    return targetType;
}
function parseRecord(recordDefinition, currentFQN, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, annotationType, annotationsTerm) {
    var targetType;
    if (!recordDefinition.type && annotationsTerm) {
        targetType = inferTypeFromTerm(annotationsTerm, parserOutput, currentTarget.fullyQualifiedName);
    }
    else {
        targetType = unalias(parserOutput.references, recordDefinition.type);
    }
    var annotationTerm = {
        $Type: targetType,
        fullyQualifiedName: currentFQN
    };
    var annotationContent = {};
    if (recordDefinition.annotations && Array.isArray(recordDefinition.annotations)) {
        var subAnnotationList = {
            target: currentFQN,
            annotations: recordDefinition.annotations,
            __source: annotationSource
        };
        unresolvedAnnotations.push(subAnnotationList);
    }
    recordDefinition.propertyValues.forEach(function (propertyValue) {
        annotationContent[propertyValue.name] = parseValue(propertyValue.value, currentFQN + "/" + propertyValue.name, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, annotationType, annotationsTerm);
        if (propertyValue.annotations && Array.isArray(propertyValue.annotations)) {
            var subAnnotationList = {
                target: currentFQN + "/" + propertyValue.name,
                annotations: propertyValue.annotations,
                __source: annotationSource
            };
            unresolvedAnnotations.push(subAnnotationList);
        }
        if (annotationContent.hasOwnProperty("Action") &&
            (annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" ||
                annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldWithAction")) {
            annotationContent.ActionTarget =
                (currentTarget.actions && currentTarget.actions[annotationContent.Action]) ||
                    objectMap[annotationContent.Action];
            if (!annotationContent.ActionTarget) {
                // Add to diagnostics debugger;
                ANNOTATION_ERRORS.push({
                    message: "Unable to resolve the action " +
                        annotationContent.Action +
                        " defined for " +
                        annotationTerm.fullyQualifiedName
                });
            }
        }
    });
    return Object.assign(annotationTerm, annotationContent);
}
function getOrInferCollectionType(collectionDefinition) {
    var type = collectionDefinition.type;
    if (type === undefined && collectionDefinition.length > 0) {
        var firstColItem = collectionDefinition[0];
        if (firstColItem.hasOwnProperty("PropertyPath")) {
            type = "PropertyPath";
        }
        else if (firstColItem.hasOwnProperty("Path")) {
            type = "Path";
        }
        else if (firstColItem.hasOwnProperty("AnnotationPath")) {
            type = "AnnotationPath";
        }
        else if (firstColItem.hasOwnProperty("NavigationPropertyPath")) {
            type = "NavigationPropertyPath";
        }
        else if (typeof firstColItem === "object" &&
            (firstColItem.hasOwnProperty("type") || firstColItem.hasOwnProperty("propertyValues"))) {
            type = "Record";
        }
        else if (typeof firstColItem === "string") {
            type = "String";
        }
    }
    else if (type === undefined) {
        type = "EmptyCollection";
    }
    return type;
}
function parseCollection(collectionDefinition, parentFQN, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, annotationType, annotationsTerm) {
    var collectionDefinitionType = getOrInferCollectionType(collectionDefinition);
    switch (collectionDefinitionType) {
        case "PropertyPath":
            return collectionDefinition.map(function (propertyPath, propertyIdx) {
                return {
                    type: "PropertyPath",
                    value: propertyPath.PropertyPath,
                    fullyQualifiedName: parentFQN + "/" + propertyIdx,
                    $target: resolveTarget(objectMap, currentTarget, propertyPath.PropertyPath, false, false, annotationType, annotationsTerm)
                };
            });
        case "Path":
            return collectionDefinition.map(function (pathValue) {
                var $target = resolveTarget(objectMap, currentTarget, pathValue.Path, true, false, annotationType, annotationsTerm);
                var path = new Path(pathValue, $target, annotationsTerm, annotationType, "");
                toResolve.push({
                    inline: isAnnotationPath(pathValue.Path),
                    toResolve: path
                });
                return path;
            });
        case "AnnotationPath":
            return collectionDefinition.map(function (annotationPath, annotationIdx) {
                var annotationTarget = resolveTarget(objectMap, currentTarget, annotationPath.AnnotationPath, true, false, annotationType, annotationsTerm);
                var annotationCollectionElement = {
                    type: "AnnotationPath",
                    value: annotationPath.AnnotationPath,
                    fullyQualifiedName: parentFQN + "/" + annotationIdx,
                    $target: annotationTarget,
                    annotationType: annotationType,
                    annotationsTerm: annotationsTerm,
                    term: "",
                    path: ""
                };
                toResolve.push({
                    inline: false,
                    toResolve: annotationCollectionElement
                });
                return annotationCollectionElement;
            });
        case "NavigationPropertyPath":
            return collectionDefinition.map(function (navPropertyPath, navPropIdx) {
                return {
                    type: "NavigationPropertyPath",
                    value: navPropertyPath.NavigationPropertyPath,
                    fullyQualifiedName: parentFQN + "/" + navPropIdx,
                    $target: resolveTarget(objectMap, currentTarget, navPropertyPath.NavigationPropertyPath, false, false, annotationType, annotationsTerm)
                };
            });
        case "Record":
            return collectionDefinition.map(function (recordDefinition, recordIdx) {
                return parseRecord(recordDefinition, parentFQN + "/" + recordIdx, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, annotationType, annotationsTerm);
            });
        case "Apply":
        case "If":
        case "Eq":
        case "Ne":
        case "Lt":
        case "Gt":
        case "Le":
        case "Ge":
        case "Not":
        case "And":
        case "Or":
            return collectionDefinition.map(function (ifValue) {
                return ifValue;
            });
        case "String":
            return collectionDefinition.map(function (stringValue) {
                if (typeof stringValue === "string") {
                    return stringValue;
                }
                else if (stringValue === undefined) {
                    return stringValue;
                }
                else {
                    return stringValue.String;
                }
            });
        default:
            if (collectionDefinition.length === 0) {
                return [];
            }
            throw new Error("Unsupported case");
    }
}
function convertAnnotation(annotation, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations) {
    if (annotation.record) {
        var annotationType_1 = annotation.record.type
            ? unalias(parserOutput.references, annotation.record.type)
            : inferTypeFromTerm(annotation.term, parserOutput, currentTarget.fullyQualifiedName);
        var annotationTerm_1 = {
            $Type: annotationType_1,
            fullyQualifiedName: annotation.fullyQualifiedName,
            qualifier: annotation.qualifier
        };
        var annotationContent_1 = {};
        annotation.record.propertyValues.forEach(function (propertyValue) {
            annotationContent_1[propertyValue.name] = parseValue(propertyValue.value, annotation.fullyQualifiedName + "/" + propertyValue.name, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, annotationType_1, annotation.term);
            if (annotationContent_1.hasOwnProperty("Action") &&
                (!annotation.record ||
                    annotationTerm_1.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" ||
                    annotationTerm_1.$Type === "com.sap.vocabularies.UI.v1.DataFieldWithAction")) {
                annotationContent_1.ActionTarget =
                    (currentTarget.actions && currentTarget.actions[annotationContent_1.Action]) ||
                        objectMap[annotationContent_1.Action];
                if (!annotationContent_1.ActionTarget) {
                    ANNOTATION_ERRORS.push({
                        message: "Unable to resolve the action " +
                            annotationContent_1.Action +
                            " defined for " +
                            annotation.fullyQualifiedName
                    });
                    // Add to diagnostics
                    // debugger;
                }
            }
        });
        return Object.assign(annotationTerm_1, annotationContent_1);
    }
    else if (annotation.collection === undefined) {
        if (annotation.value) {
            return parseValue(annotation.value, annotation.fullyQualifiedName, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, "", annotation.term);
        }
        else {
            return true;
        }
    }
    else if (annotation.collection) {
        var collection = parseCollection(annotation.collection, annotation.fullyQualifiedName, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations, "", annotation.term);
        collection.fullyQualifiedName = annotation.fullyQualifiedName;
        return collection;
    }
    else {
        throw new Error("Unsupported case");
    }
}
function createResolvePathFn(entityType, objectMap) {
    return function (relativePath, includeVisitedObjects) {
        var annotationTerm = "";
        var annotationType = "";
        return resolveTarget(objectMap, entityType, relativePath, false, includeVisitedObjects, annotationType, annotationTerm);
    };
}
function resolveNavigationProperties(entityTypes, associations, objectMap) {
    entityTypes.forEach(function (entityType) {
        entityType.navigationProperties = entityType.navigationProperties.map(function (navProp) {
            var outNavProp = {
                _type: "NavigationProperty",
                name: navProp.name,
                fullyQualifiedName: navProp.fullyQualifiedName,
                partner: navProp.hasOwnProperty("partner") ? navProp.partner : undefined,
                // targetTypeName: FullyQualifiedName;
                // targetType: EntityType;
                isCollection: navProp.hasOwnProperty("isCollection") ? navProp.isCollection : false,
                containsTarget: navProp.hasOwnProperty("containsTarget")
                    ? navProp.containsTarget
                    : false,
                referentialConstraint: navProp.referentialConstraint
                    ? navProp.referentialConstraint
                    : [],
                annotations: {}
            };
            if (navProp.targetTypeName) {
                outNavProp.targetType = objectMap[navProp.targetTypeName];
            }
            else if (navProp.relationship) {
                var targetAssociation = associations.find(function (association) { return association.fullyQualifiedName === navProp.relationship; });
                if (targetAssociation) {
                    var associationEnd = targetAssociation.associationEnd.find(function (end) { return end.role === navProp.toRole; });
                    if (associationEnd) {
                        outNavProp.targetType = objectMap[associationEnd.type];
                        outNavProp.isCollection = associationEnd.multiplicity === "*";
                    }
                }
            }
            if (outNavProp.targetType) {
                outNavProp.targetTypeName = outNavProp.targetType.fullyQualifiedName;
            }
            var outNavPropReq = outNavProp;
            objectMap[outNavPropReq.fullyQualifiedName] = outNavPropReq;
            return outNavPropReq;
        });
        entityType.resolvePath = createResolvePathFn(entityType, objectMap);
    });
}
function linkActionsToEntityType(namespace, actions, objectMap) {
    actions.forEach(function (action) {
        if (!action.annotations) {
            action.annotations = {};
        }
        if (action.isBound) {
            var sourceEntityType = objectMap[action.sourceType];
            action.sourceEntityType = sourceEntityType;
            if (sourceEntityType) {
                if (!sourceEntityType.actions) {
                    sourceEntityType.actions = {};
                }
                sourceEntityType.actions[action.name] = action;
                sourceEntityType.actions[namespace + "." + action.name] = action;
            }
            action.returnEntityType = objectMap[action.returnType];
        }
    });
}
function linkEntityTypeToEntitySet(entitySets, objectMap, references) {
    entitySets.forEach(function (entitySet) {
        entitySet.entityType = objectMap[entitySet.entityTypeName];
        if (!entitySet.entityType) {
            entitySet.entityType = objectMap[unalias(references, entitySet.entityTypeName)];
        }
        if (!entitySet.annotations) {
            entitySet.annotations = {};
        }
        if (!entitySet.entityType.annotations) {
            entitySet.entityType.annotations = {};
        }
        entitySet.entityType.keys.forEach(function (keyProp) {
            keyProp.isKey = true;
        });
    });
}
function linkPropertiesToComplexTypes(entityTypes, objectMap) {
    entityTypes.forEach(function (entityType) {
        entityType.entityProperties.forEach(function (entityProperty) {
            if (!entityProperty.annotations) {
                entityProperty.annotations = {};
            }
            if (entityProperty.type.indexOf("Edm") === -1) {
                if (entityProperty.type.startsWith("Collection")) {
                    var complexTypeName = entityProperty.type.substr(11, entityProperty.type.length - 12);
                    var complexType = objectMap[complexTypeName];
                    if (complexType) {
                        entityProperty.targetType = complexType;
                    }
                }
                else {
                    var complexType = objectMap[entityProperty.type];
                    if (complexType) {
                        entityProperty.targetType = complexType;
                    }
                }
            }
        });
    });
}
function prepareComplexTypes(complexTypes, associations, objectMap) {
    complexTypes.forEach(function (complexType) {
        complexType.annotations = {};
        complexType.properties.forEach(function (property) {
            if (!property.annotations) {
                property.annotations = {};
            }
        });
        complexType.navigationProperties = complexType.navigationProperties.map(function (navProp) {
            if (!navProp.annotations) {
                navProp.annotations = {};
            }
            var outNavProp = {
                _type: "NavigationProperty",
                name: navProp.name,
                fullyQualifiedName: navProp.fullyQualifiedName,
                partner: navProp.hasOwnProperty("partner") ? navProp.partner : undefined,
                // targetTypeName: FullyQualifiedName;
                // targetType: EntityType;
                isCollection: navProp.hasOwnProperty("isCollection") ? navProp.isCollection : false,
                containsTarget: navProp.hasOwnProperty("containsTarget")
                    ? navProp.containsTarget
                    : false,
                referentialConstraint: navProp.referentialConstraint
                    ? navProp.referentialConstraint
                    : []
            };
            if (navProp.targetTypeName) {
                outNavProp.targetType = objectMap[navProp.targetTypeName];
            }
            else if (navProp.relationship) {
                var targetAssociation = associations.find(function (association) { return association.fullyQualifiedName === navProp.relationship; });
                if (targetAssociation) {
                    var associationEnd = targetAssociation.associationEnd.find(function (end) { return end.role === navProp.toRole; });
                    if (associationEnd) {
                        outNavProp.targetType = objectMap[associationEnd.type];
                        outNavProp.isCollection = associationEnd.multiplicity === "*";
                    }
                }
            }
            if (outNavProp.targetType) {
                outNavProp.targetTypeName = outNavProp.targetType.fullyQualifiedName;
            }
            var outNavPropReq = outNavProp;
            objectMap[outNavPropReq.fullyQualifiedName] = outNavPropReq;
            return outNavPropReq;
        });
    });
}
function splitTerm(references, termValue) {
    var aliasedTerm = alias(references, termValue);
    var lastDot = aliasedTerm.lastIndexOf(".");
    var termAlias = aliasedTerm.substr(0, lastDot);
    var term = aliasedTerm.substr(lastDot + 1);
    return [termAlias, term];
}
/**
 * Resolve a specific path
 * @param sPath
 */
function createGlobalResolve(convertedOutput, objectMap) {
    return function resolvePath(sPath) {
        var aPathSplit = sPath.split("/");
        if (aPathSplit.shift() !== "") {
            throw new Error("Cannot deal with relative path");
        }
        var entitySetName = aPathSplit.shift();
        var entitySet = convertedOutput.entitySets.find(function (et) { return et.name === entitySetName; });
        if (!entitySet) {
            return {
                target: convertedOutput.entityContainer,
                objectPath: [convertedOutput.entityContainer]
            };
        }
        if (aPathSplit.length === 0) {
            return {
                target: entitySet,
                objectPath: [convertedOutput.entityContainer, entitySet]
            };
        }
        else {
            var targetResolution = resolveTarget(objectMap, entitySet, "/" + aPathSplit.join("/"), false, true);
            if (targetResolution.target) {
                targetResolution.visitedObjects.push(targetResolution.target);
            }
            return {
                target: targetResolution.target,
                objectPath: targetResolution.visitedObjects
            };
        }
    };
}
var ANNOTATION_ERRORS = [];
var ALL_ANNOTATION_ERRORS = {};
function convertTypes(parserOutput) {
    ANNOTATION_ERRORS = [];
    var objectMap = buildObjectMap(parserOutput);
    resolveNavigationProperties(parserOutput.schema.entityTypes, parserOutput.schema.associations, objectMap);
    if (!parserOutput.schema.entityContainer.annotations) {
        parserOutput.schema.entityContainer.annotations = {};
    }
    linkActionsToEntityType(parserOutput.schema.namespace, parserOutput.schema.actions, objectMap);
    linkEntityTypeToEntitySet(parserOutput.schema.entitySets, objectMap, parserOutput.references);
    linkPropertiesToComplexTypes(parserOutput.schema.entityTypes, objectMap);
    prepareComplexTypes(parserOutput.schema.complexTypes, parserOutput.schema.associations, objectMap);
    var toResolve = [];
    var unresolvedAnnotations = [];
    Object.keys(parserOutput.schema.annotations).forEach(function (annotationSource) {
        parserOutput.schema.annotations[annotationSource].forEach(function (annotationList) {
            var currentTargetName = unalias(parserOutput.references, annotationList.target);
            var currentTarget = objectMap[currentTargetName];
            if (!currentTarget) {
                if (currentTargetName && currentTargetName.indexOf("@") !== -1) {
                    annotationList.__source = annotationSource;
                    unresolvedAnnotations.push(annotationList);
                }
            }
            else if (typeof currentTarget === "object") {
                if (!currentTarget.annotations) {
                    currentTarget.annotations = {};
                }
                annotationList.annotations.forEach(function (annotation) {
                    var _a = splitTerm(exports.defaultReferences, annotation.term), vocAlias = _a[0], vocTerm = _a[1];
                    if (!currentTarget.annotations[vocAlias]) {
                        currentTarget.annotations[vocAlias] = {};
                    }
                    if (!currentTarget.annotations._annotations) {
                        currentTarget.annotations._annotations = {};
                    }
                    var vocTermWithQualifier = "" + vocTerm + (annotation.qualifier ? "#" + annotation.qualifier : "");
                    currentTarget.annotations[vocAlias][vocTermWithQualifier] = convertAnnotation(annotation, parserOutput, currentTarget, objectMap, toResolve, annotationSource, unresolvedAnnotations);
                    switch (typeof currentTarget.annotations[vocAlias][vocTermWithQualifier]) {
                        case "string":
                            currentTarget.annotations[vocAlias][vocTermWithQualifier] = new String(currentTarget.annotations[vocAlias][vocTermWithQualifier]);
                            break;
                        case "boolean":
                            currentTarget.annotations[vocAlias][vocTermWithQualifier] = new Boolean(currentTarget.annotations[vocAlias][vocTermWithQualifier]);
                            break;
                    }
                    if (currentTarget.annotations[vocAlias][vocTermWithQualifier] !== null &&
                        typeof currentTarget.annotations[vocAlias][vocTermWithQualifier] === "object") {
                        currentTarget.annotations[vocAlias][vocTermWithQualifier].term = unalias(exports.defaultReferences, vocAlias + "." + vocTerm);
                        currentTarget.annotations[vocAlias][vocTermWithQualifier].qualifier = annotation.qualifier;
                        currentTarget.annotations[vocAlias][vocTermWithQualifier].__source = annotationSource;
                    }
                    var annotationTarget = currentTargetName + "@" + unalias(exports.defaultReferences, vocAlias + "." + vocTermWithQualifier);
                    if (annotation.annotations && Array.isArray(annotation.annotations)) {
                        var subAnnotationList = {
                            target: annotationTarget,
                            annotations: annotation.annotations,
                            __source: annotationSource
                        };
                        unresolvedAnnotations.push(subAnnotationList);
                    }
                    else if (annotation.annotations &&
                        !currentTarget.annotations[vocAlias][vocTermWithQualifier].annotations) {
                        currentTarget.annotations[vocAlias][vocTermWithQualifier].annotations = annotation.annotations;
                    }
                    currentTarget.annotations._annotations[vocAlias + "." + vocTermWithQualifier] =
                        currentTarget.annotations[vocAlias][vocTermWithQualifier];
                    objectMap[annotationTarget] = currentTarget.annotations[vocAlias][vocTermWithQualifier];
                });
            }
        });
    });
    var extraUnresolvedAnnotations = [];
    unresolvedAnnotations.forEach(function (annotationList) {
        var currentTargetName = unalias(parserOutput.references, annotationList.target);
        var _a = currentTargetName.split("@"), baseObj = _a[0], annotationPart = _a[1];
        var targetSplit = annotationPart.split("/");
        baseObj = baseObj + "@" + targetSplit[0];
        var currentTarget = targetSplit.slice(1).reduce(function (currentObj, path) {
            if (!currentObj) {
                return null;
            }
            return currentObj[path];
        }, objectMap[baseObj]);
        if (!currentTarget) {
            ANNOTATION_ERRORS.push({
                message: "The following annotation target was not found on the service " + currentTargetName
            });
            // console.log("Missing target again " + currentTargetName);
        }
        else if (typeof currentTarget === "object") {
            if (!currentTarget.annotations) {
                currentTarget.annotations = {};
            }
            annotationList.annotations.forEach(function (annotation) {
                var _a = splitTerm(exports.defaultReferences, annotation.term), vocAlias = _a[0], vocTerm = _a[1];
                if (!currentTarget.annotations[vocAlias]) {
                    currentTarget.annotations[vocAlias] = {};
                }
                if (!currentTarget.annotations._annotations) {
                    currentTarget.annotations._annotations = {};
                }
                var vocTermWithQualifier = "" + vocTerm + (annotation.qualifier ? "#" + annotation.qualifier : "");
                currentTarget.annotations[vocAlias][vocTermWithQualifier] = convertAnnotation(annotation, parserOutput, currentTarget, objectMap, toResolve, annotationList.__source, extraUnresolvedAnnotations);
                if (currentTarget.annotations[vocAlias][vocTermWithQualifier] !== null &&
                    typeof currentTarget.annotations[vocAlias][vocTermWithQualifier] === "object") {
                    currentTarget.annotations[vocAlias][vocTermWithQualifier].term = unalias(exports.defaultReferences, vocAlias + "." + vocTerm);
                    currentTarget.annotations[vocAlias][vocTermWithQualifier].qualifier = annotation.qualifier;
                    currentTarget.annotations[vocAlias][vocTermWithQualifier].__source = annotationList.__source;
                }
                currentTarget.annotations._annotations[vocAlias + "." + vocTermWithQualifier] =
                    currentTarget.annotations[vocAlias][vocTermWithQualifier];
                objectMap[currentTargetName + "@" + unalias(exports.defaultReferences, vocAlias + "." + vocTermWithQualifier)] =
                    currentTarget.annotations[vocAlias][vocTermWithQualifier];
            });
        }
    });
    toResolve.forEach(function (resolveable) {
        var toResolve = resolveable.toResolve;
        var targetStr = toResolve.$target;
        var resolvedTarget = objectMap[targetStr];
        var annotationsTerm = toResolve.annotationsTerm, annotationType = toResolve.annotationType;
        delete toResolve.annotationType;
        delete toResolve.annotationsTerm;
        if (resolveable.inline) {
            // inline the resolved target
            var keys = void 0;
            for (keys in toResolve)
                delete toResolve[keys];
            Object.assign(toResolve, resolvedTarget);
        }
        else {
            // assign the resolved target
            toResolve.$target = resolvedTarget;
        }
        if (!resolvedTarget) {
            toResolve.targetString = targetStr;
            if (annotationsTerm && annotationType) {
                var oErrorMsg = {
                    message: "Unable to resolve the path expression: " +
                        targetStr +
                        "\n" +
                        "\n" +
                        "Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n" +
                        "<Annotation Term = " +
                        annotationsTerm +
                        ">" +
                        "\n" +
                        "<Record Type = " +
                        annotationType +
                        ">" +
                        "\n" +
                        "<AnnotationPath = " +
                        targetStr +
                        ">"
                };
                addAnnotationErrorMessage(targetStr, oErrorMsg);
            }
            else {
                var property_1 = toResolve.term;
                var path = toResolve.path;
                var termInfo = targetStr ? targetStr.split("/")[0] : targetStr;
                var oErrorMsg = {
                    message: "Unable to resolve the path expression: " +
                        targetStr +
                        "\n" +
                        "\n" +
                        "Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n" +
                        "<Annotation Term = " +
                        termInfo +
                        ">" +
                        "\n" +
                        "<PropertyValue Property = " +
                        property_1 +
                        "        Path= " +
                        path +
                        ">"
                };
                addAnnotationErrorMessage(targetStr, oErrorMsg);
            }
        }
    });
    for (var property in ALL_ANNOTATION_ERRORS) {
        ANNOTATION_ERRORS.push(ALL_ANNOTATION_ERRORS[property][0]);
    }
    parserOutput.entitySets = parserOutput.schema.entitySets;
    var convertedOutput = {
        version: parserOutput.version,
        annotations: parserOutput.schema.annotations,
        namespace: parserOutput.schema.namespace,
        entityContainer: parserOutput.schema.entityContainer,
        actions: parserOutput.schema.actions,
        entitySets: parserOutput.schema.entitySets,
        entityTypes: parserOutput.schema.entityTypes,
        complexTypes: parserOutput.schema.complexTypes,
        references: exports.defaultReferences,
        diagnostics: ANNOTATION_ERRORS.concat()
    };
    convertedOutput.resolvePath = createGlobalResolve(convertedOutput, objectMap);
    return convertedOutput;
}
exports.convertTypes = convertTypes;
function revertValueToGenericType(references, value) {
    var result;
    if (typeof value === "string") {
        var valueMatches_1 = value.match(/(\w+)\.\w+\/.*/);
        if (valueMatches_1 && references.find(function (ref) { return ref.alias === valueMatches_1[1]; })) {
            result = {
                type: "EnumMember",
                EnumMember: value
            };
        }
        else {
            result = {
                type: "String",
                String: value
            };
        }
    }
    else if (Array.isArray(value)) {
        result = {
            type: "Collection",
            Collection: value.map(function (anno) { return revertCollectionItemToGenericType(references, anno); })
        };
    }
    else if (typeof value === "boolean") {
        result = {
            type: "Bool",
            Bool: value
        };
    }
    else if (typeof value === "number") {
        if (value.toString() === value.toFixed()) {
            result = {
                type: "Int",
                Int: value
            };
        }
        else {
            result = {
                type: "Decimal",
                Decimal: value
            };
        }
    }
    else if (typeof value === "object" && value.isDecimal && value.isDecimal()) {
        result = {
            type: "Decimal",
            Decimal: value.valueOf()
        };
    }
    else if (value.type === "Path") {
        result = {
            type: "Path",
            Path: value.path
        };
    }
    else if (value.type === "AnnotationPath") {
        result = {
            type: "AnnotationPath",
            AnnotationPath: value.value
        };
    }
    else if (value.type === "PropertyPath") {
        result = {
            type: "PropertyPath",
            PropertyPath: value.value
        };
    }
    else if (value.type === "NavigationPropertyPath") {
        result = {
            type: "NavigationPropertyPath",
            NavigationPropertyPath: value.value
        };
    }
    else if (Object.prototype.hasOwnProperty.call(value, "$Type")) {
        result = {
            type: "Record",
            Record: revertCollectionItemToGenericType(references, value)
        };
    }
    return result;
}
function revertCollectionItemToGenericType(references, collectionItem) {
    if (typeof collectionItem === "string") {
        return collectionItem;
    }
    else if (typeof collectionItem === "object") {
        if (collectionItem.hasOwnProperty("$Type")) {
            // Annotation Record
            var outItem_1 = {
                type: collectionItem.$Type,
                propertyValues: []
            };
            // Could validate keys and type based on $Type
            Object.keys(collectionItem).forEach(function (collectionKey) {
                if (collectionKey !== "$Type" &&
                    collectionKey !== "term" &&
                    collectionKey !== "__source" &&
                    collectionKey !== "qualifier" &&
                    collectionKey !== "ActionTarget" &&
                    collectionKey !== "fullyQualifiedName" &&
                    collectionKey !== "annotations") {
                    var value = collectionItem[collectionKey];
                    outItem_1.propertyValues.push({
                        name: collectionKey,
                        value: revertValueToGenericType(references, value)
                    });
                }
                else if (collectionKey === "annotations") {
                    var annotations_1 = collectionItem[collectionKey];
                    outItem_1.annotations = [];
                    Object.keys(annotations_1)
                        .filter(function (key) { return key !== "_annotations"; })
                        .forEach(function (key) {
                        Object.keys(annotations_1[key]).forEach(function (term) {
                            var _a;
                            var parsedAnnotation = revertTermToGenericType(references, annotations_1[key][term]);
                            if (!parsedAnnotation.term) {
                                var unaliasedTerm = unalias(references, key + "." + term);
                                if (unaliasedTerm) {
                                    var qualifiedSplit = unaliasedTerm.split("#");
                                    parsedAnnotation.term = qualifiedSplit[0];
                                    if (qualifiedSplit.length > 1) {
                                        parsedAnnotation.qualifier = qualifiedSplit[1];
                                    }
                                }
                            }
                            (_a = outItem_1.annotations) === null || _a === void 0 ? void 0 : _a.push(parsedAnnotation);
                        });
                    });
                }
            });
            return outItem_1;
        }
        else if (collectionItem.type === "PropertyPath") {
            return {
                type: "PropertyPath",
                PropertyPath: collectionItem.value
            };
        }
        else if (collectionItem.type === "AnnotationPath") {
            return {
                type: "AnnotationPath",
                AnnotationPath: collectionItem.value
            };
        }
        else if (collectionItem.type === "NavigationPropertyPath") {
            return {
                type: "NavigationPropertyPath",
                NavigationPropertyPath: collectionItem.value
            };
        }
    }
}
function revertTermToGenericType(references, annotation) {
    var baseAnnotation = {
        term: annotation.term,
        qualifier: annotation.qualifier
    };
    if (Array.isArray(annotation)) {
        // Collection
        if (annotation.hasOwnProperty("annotations")) {
            baseAnnotation.annotations = [];
            var currentAnnotations_1 = annotation.annotations;
            Object.keys(currentAnnotations_1)
                .filter(function (key) { return key !== "_annotations"; })
                .forEach(function (key) {
                Object.keys(currentAnnotations_1[key]).forEach(function (term) {
                    var _a;
                    var parsedAnnotation = revertTermToGenericType(references, currentAnnotations_1[key][term]);
                    if (!parsedAnnotation.term) {
                        var unaliasedTerm = unalias(references, key + "." + term);
                        if (unaliasedTerm) {
                            var qualifiedSplit = unaliasedTerm.split("#");
                            parsedAnnotation.term = qualifiedSplit[0];
                            if (qualifiedSplit.length > 1) {
                                parsedAnnotation.qualifier = qualifiedSplit[1];
                            }
                        }
                    }
                    (_a = baseAnnotation.annotations) === null || _a === void 0 ? void 0 : _a.push(parsedAnnotation);
                });
            });
        }
        return __assign(__assign({}, baseAnnotation), { collection: annotation.map(function (anno) { return revertCollectionItemToGenericType(references, anno); }) });
    }
    else if (annotation.hasOwnProperty("$Type")) {
        return __assign(__assign({}, baseAnnotation), { record: revertCollectionItemToGenericType(references, annotation) });
    }
    else {
        return __assign(__assign({}, baseAnnotation), { value: revertValueToGenericType(references, annotation) });
    }
}
exports.revertTermToGenericType = revertTermToGenericType;
