import {
	Annotation as EdmAnnotation,
	AnnotationList,
	AnnotationRecord,
	AnnotationTerm,
	ConverterOutput,
	Expression,
	ParserOutput,
	PathExpression,
	PropertyPath,
	PropertyValue,
	AnnotationPathExpression,
	NavigationPropertyPathExpression,
	PropertyPathExpression
} from "@sap-ux/vocabularies-types";
import {
	Association,
	GenericNavigationProperty,
	Reference,
	Property as ParserProperty,
	EntityType as ParserEntityType,
	ComplexType as ParserComplexType,
	V2NavigationProperty,
	V4NavigationProperty
} from "@sap-ux/vocabularies-types/dist/Parser";
import {
	Annotation,
	EntityType,
	ComplexType,
	Action,
	EntitySet,
	Property,
	NavigationProperty,
	EntityContainer,
	ServiceObjectAndAnnotation,
	ResolutionTarget
} from "@sap-ux/vocabularies-types/dist/Converter";
import { parse } from "ts-node";

class Path {
	path: string;
	$target: string;
	type: string;
	annotationsTerm: string;
	annotationType: string;
	term: string;

	constructor(
		pathExpression: PathExpression,
		targetName: string,
		annotationsTerm: string,
		annotationType: string,
		term: string
	) {
		this.path = pathExpression.Path;
		this.type = "Path";
		this.$target = targetName;
		(this.term = term), (this.annotationType = annotationType), (this.annotationsTerm = annotationsTerm);
	}
}

enum TermToTypes {
	"Org.OData.Authorization.V1.SecuritySchemes" = "Org.OData.Authorization.V1.SecurityScheme",
	"Org.OData.Authorization.V1.Authorizations" = "Org.OData.Authorization.V1.Authorization",
	"Org.OData.Core.V1.Revisions" = "Org.OData.Core.V1.RevisionType",
	"Org.OData.Core.V1.Links" = "Org.OData.Core.V1.Link",
	"Org.OData.Core.V1.Example" = "Org.OData.Core.V1.ExampleValue",
	"Org.OData.Core.V1.Messages" = "Org.OData.Core.V1.MessageType",
	"Org.OData.Core.V1.ValueException" = "Org.OData.Core.V1.ValueExceptionType",
	"Org.OData.Core.V1.ResourceException" = "Org.OData.Core.V1.ResourceExceptionType",
	"Org.OData.Core.V1.DataModificationException" = "Org.OData.Core.V1.DataModificationExceptionType",
	"Org.OData.Core.V1.IsLanguageDependent" = "Org.OData.Core.V1.Tag",
	"Org.OData.Core.V1.DereferenceableIDs" = "Org.OData.Core.V1.Tag",
	"Org.OData.Core.V1.ConventionalIDs" = "Org.OData.Core.V1.Tag",
	"Org.OData.Core.V1.Permissions" = "Org.OData.Core.V1.Permission",
	"Org.OData.Core.V1.DefaultNamespace" = "Org.OData.Core.V1.Tag",
	"Org.OData.Core.V1.Immutable" = "Org.OData.Core.V1.Tag",
	"Org.OData.Core.V1.Computed" = "Org.OData.Core.V1.Tag",
	"Org.OData.Core.V1.ComputedDefaultValue" = "Org.OData.Core.V1.Tag",
	"Org.OData.Core.V1.IsURL" = "Org.OData.Core.V1.Tag",
	"Org.OData.Core.V1.IsMediaType" = "Org.OData.Core.V1.Tag",
	"Org.OData.Core.V1.ContentDisposition" = "Org.OData.Core.V1.ContentDispositionType",
	"Org.OData.Core.V1.OptimisticConcurrency" = "Edm.PropertyPath",
	"Org.OData.Core.V1.AdditionalProperties" = "Org.OData.Core.V1.Tag",
	"Org.OData.Core.V1.AutoExpand" = "Org.OData.Core.V1.Tag",
	"Org.OData.Core.V1.AutoExpandReferences" = "Org.OData.Core.V1.Tag",
	"Org.OData.Core.V1.MayImplement" = "Org.OData.Core.V1.QualifiedTypeName",
	"Org.OData.Core.V1.Ordered" = "Org.OData.Core.V1.Tag",
	"Org.OData.Core.V1.PositionalInsert" = "Org.OData.Core.V1.Tag",
	"Org.OData.Core.V1.AlternateKeys" = "Org.OData.Core.V1.AlternateKey",
	"Org.OData.Core.V1.OptionalParameter" = "Org.OData.Core.V1.OptionalParameterType",
	"Org.OData.Core.V1.OperationAvailable" = "Edm.Boolean",
	"Org.OData.Core.V1.SymbolicName" = "Org.OData.Core.V1.SimpleIdentifier",
	"Org.OData.Capabilities.V1.ConformanceLevel" = "Org.OData.Capabilities.V1.ConformanceLevelType",
	"Org.OData.Capabilities.V1.AsynchronousRequestsSupported" = "Org.OData.Core.V1.Tag",
	"Org.OData.Capabilities.V1.BatchContinueOnErrorSupported" = "Org.OData.Core.V1.Tag",
	"Org.OData.Capabilities.V1.IsolationSupported" = "Org.OData.Capabilities.V1.IsolationLevel",
	"Org.OData.Capabilities.V1.CrossJoinSupported" = "Org.OData.Core.V1.Tag",
	"Org.OData.Capabilities.V1.CallbackSupported" = "Org.OData.Capabilities.V1.CallbackType",
	"Org.OData.Capabilities.V1.ChangeTracking" = "Org.OData.Capabilities.V1.ChangeTrackingType",
	"Org.OData.Capabilities.V1.CountRestrictions" = "Org.OData.Capabilities.V1.CountRestrictionsType",
	"Org.OData.Capabilities.V1.NavigationRestrictions" = "Org.OData.Capabilities.V1.NavigationRestrictionsType",
	"Org.OData.Capabilities.V1.IndexableByKey" = "Org.OData.Core.V1.Tag",
	"Org.OData.Capabilities.V1.TopSupported" = "Org.OData.Core.V1.Tag",
	"Org.OData.Capabilities.V1.SkipSupported" = "Org.OData.Core.V1.Tag",
	"Org.OData.Capabilities.V1.ComputeSupported" = "Org.OData.Core.V1.Tag",
	"Org.OData.Capabilities.V1.SelectSupport" = "Org.OData.Capabilities.V1.SelectSupportType",
	"Org.OData.Capabilities.V1.BatchSupported" = "Org.OData.Core.V1.Tag",
	"Org.OData.Capabilities.V1.BatchSupport" = "Org.OData.Capabilities.V1.BatchSupportType",
	"Org.OData.Capabilities.V1.FilterRestrictions" = "Org.OData.Capabilities.V1.FilterRestrictionsType",
	"Org.OData.Capabilities.V1.SortRestrictions" = "Org.OData.Capabilities.V1.SortRestrictionsType",
	"Org.OData.Capabilities.V1.ExpandRestrictions" = "Org.OData.Capabilities.V1.ExpandRestrictionsType",
	"Org.OData.Capabilities.V1.SearchRestrictions" = "Org.OData.Capabilities.V1.SearchRestrictionsType",
	"Org.OData.Capabilities.V1.KeyAsSegmentSupported" = "Org.OData.Core.V1.Tag",
	"Org.OData.Capabilities.V1.QuerySegmentSupported" = "Org.OData.Core.V1.Tag",
	"Org.OData.Capabilities.V1.InsertRestrictions" = "Org.OData.Capabilities.V1.InsertRestrictionsType",
	"Org.OData.Capabilities.V1.DeepInsertSupport" = "Org.OData.Capabilities.V1.DeepInsertSupportType",
	"Org.OData.Capabilities.V1.UpdateRestrictions" = "Org.OData.Capabilities.V1.UpdateRestrictionsType",
	"Org.OData.Capabilities.V1.DeepUpdateSupport" = "Org.OData.Capabilities.V1.DeepUpdateSupportType",
	"Org.OData.Capabilities.V1.DeleteRestrictions" = "Org.OData.Capabilities.V1.DeleteRestrictionsType",
	"Org.OData.Capabilities.V1.CollectionPropertyRestrictions" = "Org.OData.Capabilities.V1.CollectionPropertyRestrictionsType",
	"Org.OData.Capabilities.V1.OperationRestrictions" = "Org.OData.Capabilities.V1.OperationRestrictionsType",
	"Org.OData.Capabilities.V1.AnnotationValuesInQuerySupported" = "Org.OData.Core.V1.Tag",
	"Org.OData.Capabilities.V1.ModificationQueryOptions" = "Org.OData.Capabilities.V1.ModificationQueryOptionsType",
	"Org.OData.Capabilities.V1.ReadRestrictions" = "Org.OData.Capabilities.V1.ReadRestrictionsType",
	"Org.OData.Capabilities.V1.CustomHeaders" = "Org.OData.Capabilities.V1.CustomParameter",
	"Org.OData.Capabilities.V1.CustomQueryOptions" = "Org.OData.Capabilities.V1.CustomParameter",
	"Org.OData.Capabilities.V1.MediaLocationUpdateSupported" = "Org.OData.Core.V1.Tag",
	"Org.OData.Aggregation.V1.ApplySupported" = "Org.OData.Aggregation.V1.ApplySupportedType",
	"Org.OData.Aggregation.V1.Groupable" = "Org.OData.Core.V1.Tag",
	"Org.OData.Aggregation.V1.Aggregatable" = "Org.OData.Core.V1.Tag",
	"Org.OData.Aggregation.V1.ContextDefiningProperties" = "Edm.PropertyPath",
	"Org.OData.Aggregation.V1.LeveledHierarchy" = "Edm.PropertyPath",
	"Org.OData.Aggregation.V1.RecursiveHierarchy" = "Org.OData.Aggregation.V1.RecursiveHierarchyType",
	"Org.OData.Aggregation.V1.AvailableOnAggregates" = "Org.OData.Aggregation.V1.AvailableOnAggregatesType",
	"Org.OData.Validation.V1.Minimum" = "Edm.PrimitiveType",
	"Org.OData.Validation.V1.Maximum" = "Edm.PrimitiveType",
	"Org.OData.Validation.V1.Exclusive" = "Org.OData.Core.V1.Tag",
	"Org.OData.Validation.V1.AllowedValues" = "Org.OData.Validation.V1.AllowedValue",
	"Org.OData.Validation.V1.MultipleOf" = "Edm.Decimal",
	"Org.OData.Validation.V1.Constraint" = "Org.OData.Validation.V1.ConstraintType",
	"Org.OData.Validation.V1.ItemsOf" = "Org.OData.Validation.V1.ItemsOfType",
	"Org.OData.Validation.V1.OpenPropertyTypeConstraint" = "Org.OData.Core.V1.QualifiedTypeName",
	"Org.OData.Validation.V1.DerivedTypeConstraint" = "Org.OData.Core.V1.QualifiedTypeName",
	"Org.OData.Validation.V1.AllowedTerms" = "Org.OData.Core.V1.QualifiedTermName",
	"Org.OData.Validation.V1.ApplicableTerms" = "Org.OData.Core.V1.QualifiedTermName",
	"Org.OData.Validation.V1.MaxItems" = "Edm.Int64",
	"Org.OData.Validation.V1.MinItems" = "Edm.Int64",
	"Org.OData.Measures.V1.Scale" = "Edm.Byte",
	"Org.OData.Measures.V1.DurationGranularity" = "Org.OData.Measures.V1.DurationGranularityType",
	"com.sap.vocabularies.Analytics.v1.Dimension" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Analytics.v1.Measure" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Analytics.v1.AccumulativeMeasure" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Analytics.v1.RolledUpPropertyCount" = "Edm.Int16",
	"com.sap.vocabularies.Analytics.v1.PlanningAction" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Analytics.v1.AggregatedProperties" = "com.sap.vocabularies.Analytics.v1.AggregatedPropertyType",
	"com.sap.vocabularies.Common.v1.ServiceVersion" = "Edm.Int32",
	"com.sap.vocabularies.Common.v1.ServiceSchemaVersion" = "Edm.Int32",
	"com.sap.vocabularies.Common.v1.TextFor" = "Edm.PropertyPath",
	"com.sap.vocabularies.Common.v1.IsLanguageIdentifier" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.TextFormat" = "com.sap.vocabularies.Common.v1.TextFormatType",
	"com.sap.vocabularies.Common.v1.IsDigitSequence" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsUpperCase" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsCurrency" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsUnit" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.UnitSpecificScale" = "Edm.PrimitiveType",
	"com.sap.vocabularies.Common.v1.UnitSpecificPrecision" = "Edm.PrimitiveType",
	"com.sap.vocabularies.Common.v1.SecondaryKey" = "Edm.PropertyPath",
	"com.sap.vocabularies.Common.v1.MinOccurs" = "Edm.Int64",
	"com.sap.vocabularies.Common.v1.MaxOccurs" = "Edm.Int64",
	"com.sap.vocabularies.Common.v1.AssociationEntity" = "Edm.NavigationPropertyPath",
	"com.sap.vocabularies.Common.v1.DerivedNavigation" = "Edm.NavigationPropertyPath",
	"com.sap.vocabularies.Common.v1.Masked" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.MaskedAlways" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.SemanticObjectMapping" = "com.sap.vocabularies.Common.v1.SemanticObjectMappingType",
	"com.sap.vocabularies.Common.v1.IsInstanceAnnotation" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.FilterExpressionRestrictions" = "com.sap.vocabularies.Common.v1.FilterExpressionRestrictionType",
	"com.sap.vocabularies.Common.v1.FieldControl" = "com.sap.vocabularies.Common.v1.FieldControlType",
	"com.sap.vocabularies.Common.v1.Application" = "com.sap.vocabularies.Common.v1.ApplicationType",
	"com.sap.vocabularies.Common.v1.Timestamp" = "Edm.DateTimeOffset",
	"com.sap.vocabularies.Common.v1.ErrorResolution" = "com.sap.vocabularies.Common.v1.ErrorResolutionType",
	"com.sap.vocabularies.Common.v1.Messages" = "Edm.ComplexType",
	"com.sap.vocabularies.Common.v1.numericSeverity" = "com.sap.vocabularies.Common.v1.NumericMessageSeverityType",
	"com.sap.vocabularies.Common.v1.MaximumNumericMessageSeverity" = "com.sap.vocabularies.Common.v1.NumericMessageSeverityType",
	"com.sap.vocabularies.Common.v1.IsActionCritical" = "Edm.Boolean",
	"com.sap.vocabularies.Common.v1.Attributes" = "Edm.PropertyPath",
	"com.sap.vocabularies.Common.v1.RelatedRecursiveHierarchy" = "Edm.AnnotationPath",
	"com.sap.vocabularies.Common.v1.Interval" = "com.sap.vocabularies.Common.v1.IntervalType",
	"com.sap.vocabularies.Common.v1.ResultContext" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.WeakReferentialConstraint" = "com.sap.vocabularies.Common.v1.WeakReferentialConstraintType",
	"com.sap.vocabularies.Common.v1.IsNaturalPerson" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.ValueList" = "com.sap.vocabularies.Common.v1.ValueListType",
	"com.sap.vocabularies.Common.v1.ValueListRelevantQualifiers" = "com.sap.vocabularies.Common.v1.SimpleIdentifier",
	"com.sap.vocabularies.Common.v1.ValueListWithFixedValues" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.ValueListMapping" = "com.sap.vocabularies.Common.v1.ValueListMappingType",
	"com.sap.vocabularies.Common.v1.IsCalendarYear" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsCalendarHalfyear" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsCalendarQuarter" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsCalendarMonth" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsCalendarWeek" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsDayOfCalendarMonth" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsDayOfCalendarYear" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsCalendarYearHalfyear" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsCalendarYearQuarter" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsCalendarYearMonth" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsCalendarYearWeek" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsCalendarDate" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsFiscalYear" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsFiscalPeriod" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsFiscalYearPeriod" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsFiscalQuarter" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsFiscalYearQuarter" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsFiscalWeek" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsFiscalYearWeek" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsDayOfFiscalYear" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.IsFiscalYearVariant" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.MutuallyExclusiveTerm" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Common.v1.DraftRoot" = "com.sap.vocabularies.Common.v1.DraftRootType",
	"com.sap.vocabularies.Common.v1.DraftNode" = "com.sap.vocabularies.Common.v1.DraftNodeType",
	"com.sap.vocabularies.Common.v1.DraftActivationVia" = "com.sap.vocabularies.Common.v1.SimpleIdentifier",
	"com.sap.vocabularies.Common.v1.EditableFieldFor" = "Edm.PropertyPath",
	"com.sap.vocabularies.Common.v1.SemanticKey" = "Edm.PropertyPath",
	"com.sap.vocabularies.Common.v1.SideEffects" = "com.sap.vocabularies.Common.v1.SideEffectsType",
	"com.sap.vocabularies.Common.v1.DefaultValuesFunction" = "com.sap.vocabularies.Common.v1.QualifiedName",
	"com.sap.vocabularies.Common.v1.FilterDefaultValue" = "Edm.PrimitiveType",
	"com.sap.vocabularies.Common.v1.FilterDefaultValueHigh" = "Edm.PrimitiveType",
	"com.sap.vocabularies.Common.v1.SortOrder" = "com.sap.vocabularies.Common.v1.SortOrderType",
	"com.sap.vocabularies.Common.v1.RecursiveHierarchy" = "com.sap.vocabularies.Common.v1.RecursiveHierarchyType",
	"com.sap.vocabularies.Common.v1.CreatedAt" = "Edm.DateTimeOffset",
	"com.sap.vocabularies.Common.v1.CreatedBy" = "com.sap.vocabularies.Common.v1.UserID",
	"com.sap.vocabularies.Common.v1.ChangedAt" = "Edm.DateTimeOffset",
	"com.sap.vocabularies.Common.v1.ChangedBy" = "com.sap.vocabularies.Common.v1.UserID",
	"com.sap.vocabularies.Common.v1.ApplyMultiUnitBehaviorForSortingAndFiltering" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.CodeList.v1.CurrencyCodes" = "com.sap.vocabularies.CodeList.v1.CodeListSource",
	"com.sap.vocabularies.CodeList.v1.UnitsOfMeasure" = "com.sap.vocabularies.CodeList.v1.CodeListSource",
	"com.sap.vocabularies.CodeList.v1.StandardCode" = "Edm.PropertyPath",
	"com.sap.vocabularies.CodeList.v1.ExternalCode" = "Edm.PropertyPath",
	"com.sap.vocabularies.CodeList.v1.IsConfigurationDeprecationCode" = "Edm.Boolean",
	"com.sap.vocabularies.Communication.v1.Contact" = "com.sap.vocabularies.Communication.v1.ContactType",
	"com.sap.vocabularies.Communication.v1.Address" = "com.sap.vocabularies.Communication.v1.AddressType",
	"com.sap.vocabularies.Communication.v1.IsEmailAddress" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Communication.v1.IsPhoneNumber" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Communication.v1.Event" = "com.sap.vocabularies.Communication.v1.EventData",
	"com.sap.vocabularies.Communication.v1.Task" = "com.sap.vocabularies.Communication.v1.TaskData",
	"com.sap.vocabularies.Communication.v1.Message" = "com.sap.vocabularies.Communication.v1.MessageData",
	"com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchy" = "com.sap.vocabularies.Hierarchy.v1.RecursiveHierarchyType",
	"com.sap.vocabularies.PersonalData.v1.EntitySemantics" = "com.sap.vocabularies.PersonalData.v1.EntitySemanticsType",
	"com.sap.vocabularies.PersonalData.v1.FieldSemantics" = "com.sap.vocabularies.PersonalData.v1.FieldSemanticsType",
	"com.sap.vocabularies.PersonalData.v1.IsPotentiallyPersonal" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.PersonalData.v1.IsPotentiallySensitive" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.Session.v1.StickySessionSupported" = "com.sap.vocabularies.Session.v1.StickySessionSupportedType",
	"com.sap.vocabularies.UI.v1.HeaderInfo" = "com.sap.vocabularies.UI.v1.HeaderInfoType",
	"com.sap.vocabularies.UI.v1.Identification" = "com.sap.vocabularies.UI.v1.DataFieldAbstract",
	"com.sap.vocabularies.UI.v1.Badge" = "com.sap.vocabularies.UI.v1.BadgeType",
	"com.sap.vocabularies.UI.v1.LineItem" = "com.sap.vocabularies.UI.v1.DataFieldAbstract",
	"com.sap.vocabularies.UI.v1.StatusInfo" = "com.sap.vocabularies.UI.v1.DataFieldAbstract",
	"com.sap.vocabularies.UI.v1.FieldGroup" = "com.sap.vocabularies.UI.v1.FieldGroupType",
	"com.sap.vocabularies.UI.v1.ConnectedFields" = "com.sap.vocabularies.UI.v1.ConnectedFieldsType",
	"com.sap.vocabularies.UI.v1.GeoLocations" = "com.sap.vocabularies.UI.v1.GeoLocationType",
	"com.sap.vocabularies.UI.v1.GeoLocation" = "com.sap.vocabularies.UI.v1.GeoLocationType",
	"com.sap.vocabularies.UI.v1.Contacts" = "Edm.AnnotationPath",
	"com.sap.vocabularies.UI.v1.MediaResource" = "com.sap.vocabularies.UI.v1.MediaResourceType",
	"com.sap.vocabularies.UI.v1.DataPoint" = "com.sap.vocabularies.UI.v1.DataPointType",
	"com.sap.vocabularies.UI.v1.KPI" = "com.sap.vocabularies.UI.v1.KPIType",
	"com.sap.vocabularies.UI.v1.Chart" = "com.sap.vocabularies.UI.v1.ChartDefinitionType",
	"com.sap.vocabularies.UI.v1.ValueCriticality" = "com.sap.vocabularies.UI.v1.ValueCriticalityType",
	"com.sap.vocabularies.UI.v1.CriticalityLabels" = "com.sap.vocabularies.UI.v1.CriticalityLabelType",
	"com.sap.vocabularies.UI.v1.SelectionFields" = "Edm.PropertyPath",
	"com.sap.vocabularies.UI.v1.Facets" = "com.sap.vocabularies.UI.v1.Facet",
	"com.sap.vocabularies.UI.v1.HeaderFacets" = "com.sap.vocabularies.UI.v1.Facet",
	"com.sap.vocabularies.UI.v1.QuickViewFacets" = "com.sap.vocabularies.UI.v1.Facet",
	"com.sap.vocabularies.UI.v1.QuickCreateFacets" = "com.sap.vocabularies.UI.v1.Facet",
	"com.sap.vocabularies.UI.v1.FilterFacets" = "com.sap.vocabularies.UI.v1.ReferenceFacet",
	"com.sap.vocabularies.UI.v1.SelectionPresentationVariant" = "com.sap.vocabularies.UI.v1.SelectionPresentationVariantType",
	"com.sap.vocabularies.UI.v1.PresentationVariant" = "com.sap.vocabularies.UI.v1.PresentationVariantType",
	"com.sap.vocabularies.UI.v1.SelectionVariant" = "com.sap.vocabularies.UI.v1.SelectionVariantType",
	"com.sap.vocabularies.UI.v1.ThingPerspective" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.UI.v1.IsSummary" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.UI.v1.PartOfPreview" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.UI.v1.Map" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.UI.v1.Gallery" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.UI.v1.IsImageURL" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.UI.v1.IsImage" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.UI.v1.MultiLineText" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.UI.v1.TextArrangement" = "com.sap.vocabularies.UI.v1.TextArrangementType",
	"com.sap.vocabularies.UI.v1.Importance" = "com.sap.vocabularies.UI.v1.ImportanceType",
	"com.sap.vocabularies.UI.v1.Hidden" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.UI.v1.CreateHidden" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.UI.v1.UpdateHidden" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.UI.v1.DeleteHidden" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.UI.v1.HiddenFilter" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.UI.v1.DataFieldDefault" = "com.sap.vocabularies.UI.v1.DataFieldAbstract",
	"com.sap.vocabularies.UI.v1.Criticality" = "com.sap.vocabularies.UI.v1.CriticalityType",
	"com.sap.vocabularies.UI.v1.CriticalityCalculation" = "com.sap.vocabularies.UI.v1.CriticalityCalculationType",
	"com.sap.vocabularies.UI.v1.Emphasized" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.UI.v1.OrderBy" = "Edm.PropertyPath",
	"com.sap.vocabularies.UI.v1.ParameterDefaultValue" = "Edm.PrimitiveType",
	"com.sap.vocabularies.UI.v1.RecommendationState" = "com.sap.vocabularies.UI.v1.RecommendationStateType",
	"com.sap.vocabularies.UI.v1.RecommendationList" = "com.sap.vocabularies.UI.v1.RecommendationListType",
	"com.sap.vocabularies.UI.v1.ExcludeFromNavigationContext" = "Org.OData.Core.V1.Tag",
	"com.sap.vocabularies.HTML5.v1.CssDefaults" = "com.sap.vocabularies.HTML5.v1.CssDefaultsType"
}

export const defaultReferences: ReferencesWithMap = [
	{ alias: "Capabilities", namespace: "Org.OData.Capabilities.V1", uri: "" },
	{ alias: "Aggregation", namespace: "Org.OData.Aggregation.V1", uri: "" },
	{ alias: "Validation", namespace: "Org.OData.Validation.V1", uri: "" },
	{ namespace: "Org.OData.Core.V1", alias: "Core", uri: "" },
	{ namespace: "Org.OData.Measures.V1", alias: "Measures", uri: "" },
	{ namespace: "com.sap.vocabularies.Common.v1", alias: "Common", uri: "" },
	{ namespace: "com.sap.vocabularies.UI.v1", alias: "UI", uri: "" },
	{ namespace: "com.sap.vocabularies.Session.v1", alias: "Session", uri: "" },
	{ namespace: "com.sap.vocabularies.Analytics.v1", alias: "Analytics", uri: "" },
	{ namespace: "com.sap.vocabularies.CodeList.v1", alias: "CodeList", uri: "" },
	{ namespace: "com.sap.vocabularies.PersonalData.v1", alias: "PersonalData", uri: "" },
	{ namespace: "com.sap.vocabularies.Communication.v1", alias: "Communication", uri: "" },
	{ namespace: "com.sap.vocabularies.HTML5.v1", alias: "HTML5", uri: "" }
];

type ReferencesWithMap = Reference[] & {
	referenceMap?: Record<string, Reference>;
	reverseReferenceMap?: Record<string, Reference>;
};

function alias(references: ReferencesWithMap, unaliasedValue: string): string {
	if (!references.reverseReferenceMap) {
		references.reverseReferenceMap = references.reduce((map: Record<string, Reference>, reference) => {
			map[reference.namespace] = reference;
			return map;
		}, {});
	}
	if (!unaliasedValue) {
		return unaliasedValue;
	}
	const lastDotIndex = unaliasedValue.lastIndexOf(".");
	const namespace = unaliasedValue.substr(0, lastDotIndex);
	const value = unaliasedValue.substr(lastDotIndex + 1);
	const reference = references.reverseReferenceMap[namespace];
	if (reference) {
		return `${reference.alias}.${value}`;
	} else {
		// Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
		if (unaliasedValue.indexOf("@") !== -1) {
			const [preAlias, ...postAlias] = unaliasedValue.split("@");
			return `${preAlias}@${alias(references, postAlias.join("@"))}`;
		} else {
			return unaliasedValue;
		}
	}
}

function unalias(references: ReferencesWithMap, aliasedValue: string | undefined): string | undefined {
	if (!references.referenceMap) {
		references.referenceMap = references.reduce((map: Record<string, Reference>, reference) => {
			map[reference.alias] = reference;
			return map;
		}, {});
	}
	if (!aliasedValue) {
		return aliasedValue;
	}
	const [alias, ...value] = aliasedValue.split(".");
	const reference = references.referenceMap[alias];
	if (reference) {
		return `${reference.namespace}.${value.join(".")}`;
	} else {
		// Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
		if (aliasedValue.indexOf("@") !== -1) {
			const [preAlias, ...postAlias] = aliasedValue.split("@");
			return `${preAlias}@${unalias(references, postAlias.join("@"))}`;
		} else {
			return aliasedValue;
		}
	}
}

function buildObjectMap(parserOutput: ParserOutput): Record<string, any> {
	const objectMap: any = {};
	if (parserOutput.schema.entityContainer && parserOutput.schema.entityContainer.fullyQualifiedName) {
		objectMap[parserOutput.schema.entityContainer.fullyQualifiedName] = parserOutput.schema.entityContainer;
	}
	parserOutput.schema.entitySets.forEach(entitySet => {
		objectMap[entitySet.fullyQualifiedName] = entitySet;
	});
	parserOutput.schema.actions.forEach(action => {
		objectMap[action.fullyQualifiedName] = action;
		objectMap[action.fullyQualifiedName.split("(")[0]] = action;
		action.parameters.forEach(parameter => {
			objectMap[parameter.fullyQualifiedName] = parameter;
		});
	});
	parserOutput.schema.complexTypes.forEach(complexType => {
		objectMap[complexType.fullyQualifiedName] = complexType;
		complexType.properties.forEach(property => {
			objectMap[property.fullyQualifiedName] = property;
		});
	});
	parserOutput.schema.entityTypes.forEach(entityType => {
		objectMap[entityType.fullyQualifiedName] = entityType;
		entityType.entityProperties.forEach(property => {
			objectMap[property.fullyQualifiedName] = property;
			if (property.type.indexOf("Edm") === -1) {
				// Handle complex types
				const complexTypeDefinition = objectMap[property.type] as ComplexType;
				if (complexTypeDefinition && complexTypeDefinition.properties) {
					complexTypeDefinition.properties.forEach(complexTypeProp => {
						const complexTypePropTarget: ParserProperty = Object.assign(complexTypeProp, {
							_type: "Property",
							fullyQualifiedName: property.fullyQualifiedName + "/" + complexTypeProp.name
						});
						objectMap[complexTypePropTarget.fullyQualifiedName] = complexTypePropTarget;
					});
				}
			}
		});
		entityType.navigationProperties.forEach(navProperty => {
			objectMap[navProperty.fullyQualifiedName] = navProperty;
		});
	});

	Object.keys(parserOutput.schema.annotations).forEach(annotationSource => {
		parserOutput.schema.annotations[annotationSource].forEach(annotationList => {
			const currentTargetName = unalias(parserOutput.references, annotationList.target);
			annotationList.annotations.forEach(annotation => {
				let annotationFQN = `${currentTargetName}@${unalias(parserOutput.references, annotation.term)}`;
				if (annotation.qualifier) {
					annotationFQN += `#${annotation.qualifier}`;
				}
				if (typeof annotation !== "object") {
					debugger;
				}
				objectMap[annotationFQN] = annotation;
				(annotation as Annotation).fullyQualifiedName = annotationFQN;
			});
		});
	});
	return objectMap;
}

function combinePath(currentTarget: string, path: string): string {
	if (path.startsWith("@")) {
		return currentTarget + unalias(defaultReferences, path);
	} else {
		return currentTarget + "/" + path;
	}
}

function addAnnotationErrorMessage(path: string, oErrorMsg: any) {
	if (!ALL_ANNOTATION_ERRORS[path]) {
		ALL_ANNOTATION_ERRORS[path] = [oErrorMsg];
	} else {
		ALL_ANNOTATION_ERRORS[path].push(oErrorMsg);
	}
}

function resolveTarget(
	objectMap: any,
	currentTarget: any,
	path: string,
	pathOnly: boolean = false,
	includeVisitedObjects: boolean = false,
	annotationType?: string,
	annotationsTerm?: string
) {
	if (!path) {
		return undefined;
	}
	//const propertyPath = path;
	let aVisitedObjects: any[] = [];
	if (currentTarget && currentTarget._type === "Property") {
		currentTarget = objectMap[currentTarget.fullyQualifiedName.split("/")[0]];
	}
	path = combinePath(currentTarget.fullyQualifiedName, path);

	const pathSplit = path.split("/");
	const targetPathSplit: string[] = [];
	pathSplit.forEach(pathPart => {
		// Separate out the annotation
		if (pathPart.indexOf("@") !== -1) {
			const [path, annotationPath] = pathPart.split("@");
			targetPathSplit.push(path);
			targetPathSplit.push(`@${annotationPath}`);
		} else {
			targetPathSplit.push(pathPart);
		}
	});
	let currentPath = path;
	const target = targetPathSplit.reduce((currentValue: any, pathPart) => {
		if (pathPart === "$Type" && currentValue._type === "EntityType") {
			return currentValue;
		}
		if (pathPart.length === 0) {
			// Empty Path after an entitySet means entityType
			if (currentValue && currentValue._type === "EntitySet" && currentValue.entityType) {
				aVisitedObjects.push(currentValue);
				currentValue = currentValue.entityType;
			}
			if (currentValue && currentValue._type === "NavigationProperty" && currentValue.targetType) {
				aVisitedObjects.push(currentValue);
				currentValue = currentValue.targetType;
			}
			return currentValue;
		}
		if (includeVisitedObjects && currentValue !== null && currentValue !== undefined) {
			aVisitedObjects.push(currentValue);
		}
		if (!currentValue) {
			currentPath = pathPart;
		} else if (currentValue._type === "EntitySet" && pathPart === "$Type") {
			currentValue = currentValue.targetType;
			return currentValue;
		} else if (currentValue._type === "EntitySet" && currentValue.entityType) {
			currentPath = combinePath(currentValue.entityTypeName, pathPart);
		} else if (currentValue._type === "NavigationProperty" && currentValue.targetTypeName) {
			currentPath = combinePath(currentValue.targetTypeName, pathPart);
		} else if (currentValue._type === "NavigationProperty" && currentValue.targetType) {
			currentPath = combinePath(currentValue.targetType.fullyQualifiedName, pathPart);
		} else if (currentValue._type === "Property") {
			// ComplexType or Property
			if (currentValue.targetType) {
				currentPath = combinePath(currentValue.targetType.fullyQualifiedName, pathPart);
			} else {
				currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
			}
		} else if (currentValue._type === "Action" && currentValue.isBound) {
			currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
			if (!objectMap[currentPath]) {
				currentPath = combinePath(currentValue.sourceType, pathPart);
			}
		} else if (currentValue._type === "ActionParameter" && currentValue.isEntitySet) {
			currentPath = combinePath(currentValue.type, pathPart);
		} else if (currentValue._type === "ActionParameter" && !currentValue.isEntitySet) {
			currentPath = combinePath(
				currentTarget.fullyQualifiedName.substr(0, currentTarget.fullyQualifiedName.lastIndexOf("/")),
				pathPart
			);
			if (!objectMap[currentPath]) {
				let lastIdx = currentTarget.fullyQualifiedName.lastIndexOf("/");
				if (lastIdx === -1) {
					lastIdx = currentTarget.fullyQualifiedName.length;
				}
				currentPath = combinePath(
					(objectMap[currentTarget.fullyQualifiedName.substr(0, lastIdx)] as Action).sourceType,
					pathPart
				);
			}
		} else {
			currentPath = combinePath(currentValue.fullyQualifiedName, pathPart);
			if (pathPart !== "name" && currentValue[pathPart] !== undefined) {
				return currentValue[pathPart];
			} else if (pathPart === "$AnnotationPath" && currentValue.$target) {
				const currentContext = objectMap[currentValue.fullyQualifiedName.split("@")[0]];
				const subTarget: any = resolveTarget(objectMap, currentContext, currentValue.value, false, true);
				aVisitedObjects = aVisitedObjects.concat(subTarget.visitedObjects.slice(1));
				return subTarget.target;
			} else if (pathPart === "$Path" && currentValue.$target) {
				return currentValue.$target;
			} else if (pathPart.startsWith("$Path") && currentValue.$target) {
				const intermediateTarget = currentValue.$target;
				currentPath = combinePath(intermediateTarget.fullyQualifiedName, pathPart.substr(5));
			} else if (currentValue.hasOwnProperty("$Type") && !objectMap[currentPath]) {
				// This is now an annotation value
				const entityType = objectMap[currentValue.fullyQualifiedName.split("@")[0]];
				if (entityType) {
					currentPath = combinePath(entityType.fullyQualifiedName, pathPart);
				}
			}
		}
		return objectMap[currentPath];
	}, null);
	if (!target) {
		if (annotationsTerm && annotationType) {
			var oErrorMsg = {
				message:
					"Unable to resolve the path expression: " +
					"\n" +
					path +
					"\n" +
					"\n" +
					"Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n" +
					"<Annotation Term = " +
					annotationsTerm +
					">" +
					"\n" +
					"<Record Type = " +
					annotationType +
					">" +
					"\n" +
					"<AnnotationPath = " +
					path +
					">"
			};
			addAnnotationErrorMessage(path, oErrorMsg);
		} else {
			var oErrorMsg = {
				message:
					"Unable to resolve the path expression: " +
					path +
					"\n" +
					"\n" +
					"Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n" +
					"<Annotation Term = " +
					pathSplit[0] +
					">" +
					"\n" +
					"<PropertyValue  Path= " +
					pathSplit[1] +
					">"
			};
			addAnnotationErrorMessage(path, oErrorMsg);
		}
		// console.log("Missing target " + path);
	}
	if (pathOnly) {
		return currentPath;
	}
	if (includeVisitedObjects) {
		return {
			visitedObjects: aVisitedObjects,
			target: target
		};
	}
	return target;
}

function isAnnotationPath(pathStr: string): boolean {
	return pathStr.indexOf("@") !== -1;
}

function parseValue(
	propertyValue: Expression,
	valueFQN: string,
	parserOutput: ParserOutput,
	currentTarget: any,
	objectMap: any,
	toResolve: Resolveable[],
	annotationSource: string,
	unresolvedAnnotations: AnnotationList[],
	annotationType: string,
	annotationsTerm: string
) {
	if (propertyValue === undefined) {
		return undefined;
	}
	switch (propertyValue.type) {
		case "String":
			return propertyValue.String;
		case "Int":
			return propertyValue.Int;
		case "Bool":
			return propertyValue.Bool;
		case "Decimal":
			return propertyValue.Decimal;
		case "Date":
			return propertyValue.Date;
		case "EnumMember":
			return alias(parserOutput.references, propertyValue.EnumMember);
		case "PropertyPath":
			return {
				type: "PropertyPath",
				value: propertyValue.PropertyPath,
				fullyQualifiedName: valueFQN,
				$target: resolveTarget(
					objectMap,
					currentTarget,
					propertyValue.PropertyPath,
					false,
					false,
					annotationType,
					annotationsTerm
				)
			};
		case "NavigationPropertyPath":
			return {
				type: "NavigationPropertyPath",
				value: propertyValue.NavigationPropertyPath,
				fullyQualifiedName: valueFQN,
				$target: resolveTarget(
					objectMap,
					currentTarget,
					propertyValue.NavigationPropertyPath,
					false,
					false,
					annotationType,
					annotationsTerm
				)
			};
		case "AnnotationPath":
			const annotationTarget = resolveTarget(
				objectMap,
				currentTarget,
				unalias(parserOutput.references, propertyValue.AnnotationPath) as string,
				true,
				false,
				annotationType,
				annotationsTerm
			);
			const annotationPath = {
				type: "AnnotationPath",
				value: propertyValue.AnnotationPath,
				fullyQualifiedName: valueFQN,
				$target: annotationTarget,
				annotationType: annotationType,
				annotationsTerm: annotationsTerm,
				term: "",
				path: ""
			};
			toResolve.push({ inline: false, toResolve: annotationPath });
			return annotationPath;
		case "Path":
			const $target = resolveTarget(
				objectMap,
				currentTarget,
				propertyValue.Path,
				true,
				false,
				annotationType,
				annotationsTerm
			);
			const path = new Path(propertyValue, $target, annotationsTerm, annotationType, "");
			toResolve.push({
				inline: isAnnotationPath(propertyValue.Path),
				toResolve: path
			});
			return path;

		case "Record":
			return parseRecord(
				propertyValue.Record,
				valueFQN,
				parserOutput,
				currentTarget,
				objectMap,
				toResolve,
				annotationSource,
				unresolvedAnnotations,
				annotationType,
				annotationsTerm
			);
		case "Collection":
			return parseCollection(
				propertyValue.Collection,
				valueFQN,
				parserOutput,
				currentTarget,
				objectMap,
				toResolve,
				annotationSource,
				unresolvedAnnotations,
				annotationType,
				annotationsTerm
			);
		case "Apply":
		case "Not":
		case "Eq":
		case "Ne":
		case "Gt":
		case "Ge":
		case "Lt":
		case "Le":
		case "If":
		case "And":
		case "Or":
			return propertyValue;
	}
}

function inferTypeFromTerm(annotationsTerm: string, parserOutput: ParserOutput, annotationTarget: string) {
	const targetType = (TermToTypes as any)[annotationsTerm];
	var oErrorMsg = {
		isError: false,
		message: `The type of the record used within the term ${annotationsTerm} was not defined and was inferred as ${targetType}.
Hint: If possible, try to maintain the Type property for each Record.
<Annotations Target="${annotationTarget}">
	<Annotation Term="${annotationsTerm}">
		<Record>...</Record>
	</Annotation>
</Annotations>`
	};
	addAnnotationErrorMessage(annotationTarget + "/" + annotationsTerm, oErrorMsg);
	return targetType;
}

function parseRecord(
	recordDefinition: AnnotationRecord,
	currentFQN: string,
	parserOutput: ParserOutput,
	currentTarget: any,
	objectMap: any,
	toResolve: Resolveable[],
	annotationSource: string,
	unresolvedAnnotations: AnnotationList[],
	annotationType: string,
	annotationsTerm: string
) {
	let targetType;
	if (!recordDefinition.type && annotationsTerm) {
		targetType = inferTypeFromTerm(annotationsTerm, parserOutput, currentTarget.fullyQualifiedName);
	} else {
		targetType = unalias(parserOutput.references, recordDefinition.type);
	}
	const annotationTerm: any = {
		$Type: targetType,
		fullyQualifiedName: currentFQN
	};
	const annotationContent: any = {};
	if (recordDefinition.annotations && Array.isArray(recordDefinition.annotations)) {
		const subAnnotationList = {
			target: currentFQN,
			annotations: recordDefinition.annotations,
			__source: annotationSource
		};
		unresolvedAnnotations.push(subAnnotationList);
	}
	recordDefinition.propertyValues.forEach((propertyValue: PropertyValue) => {
		annotationContent[propertyValue.name] = parseValue(
			propertyValue.value,
			`${currentFQN}/${propertyValue.name}`,
			parserOutput,
			currentTarget,
			objectMap,
			toResolve,
			annotationSource,
			unresolvedAnnotations,
			annotationType,
			annotationsTerm
		);
		if (propertyValue.annotations && Array.isArray(propertyValue.annotations)) {
			const subAnnotationList = {
				target: `${currentFQN}/${propertyValue.name}`,
				annotations: propertyValue.annotations,
				__source: annotationSource
			};
			unresolvedAnnotations.push(subAnnotationList);
		}
		if (
			annotationContent.hasOwnProperty("Action") &&
			(annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" ||
				annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldWithAction")
		) {
			annotationContent.ActionTarget =
				(currentTarget.actions && currentTarget.actions[annotationContent.Action]) ||
				objectMap[annotationContent.Action];
			if (!annotationContent.ActionTarget) {
				// Add to diagnostics debugger;
				ANNOTATION_ERRORS.push({
					message:
						"Unable to resolve the action " +
						annotationContent.Action +
						" defined for " +
						annotationTerm.fullyQualifiedName
				});
			}
		}
	});
	return Object.assign(annotationTerm, annotationContent);
}

export type CollectionType =
	| "PropertyPath"
	| "Path"
	| "If"
	| "Apply"
	| "And"
	| "Eq"
	| "Ne"
	| "Not"
	| "Gt"
	| "Ge"
	| "Lt"
	| "Le"
	| "Or"
	| "AnnotationPath"
	| "NavigationPropertyPath"
	| "Record"
	| "String"
	| "EmptyCollection";

function getOrInferCollectionType(collectionDefinition: any[]): CollectionType {
	let type: CollectionType = (collectionDefinition as any).type;
	if (type === undefined && collectionDefinition.length > 0) {
		const firstColItem = collectionDefinition[0];
		if (firstColItem.hasOwnProperty("PropertyPath")) {
			type = "PropertyPath";
		} else if (firstColItem.hasOwnProperty("Path")) {
			type = "Path";
		} else if (firstColItem.hasOwnProperty("AnnotationPath")) {
			type = "AnnotationPath";
		} else if (firstColItem.hasOwnProperty("NavigationPropertyPath")) {
			type = "NavigationPropertyPath";
		} else if (
			typeof firstColItem === "object" &&
			(firstColItem.hasOwnProperty("type") || firstColItem.hasOwnProperty("propertyValues"))
		) {
			type = "Record";
		} else if (typeof firstColItem === "string") {
			type = "String";
		}
	} else if (type === undefined) {
		type = "EmptyCollection";
	}
	return type;
}

function parseCollection(
	collectionDefinition: any[],
	parentFQN: string,
	parserOutput: ParserOutput,
	currentTarget: any,
	objectMap: any,
	toResolve: Resolveable[],
	annotationSource: string,
	unresolvedAnnotations: AnnotationList[],
	annotationType: string,
	annotationsTerm: string
) {
	const collectionDefinitionType = getOrInferCollectionType(collectionDefinition);
	switch (collectionDefinitionType) {
		case "PropertyPath":
			return collectionDefinition.map((propertyPath, propertyIdx) => {
				return {
					type: "PropertyPath",
					value: propertyPath.PropertyPath,
					fullyQualifiedName: `${parentFQN}/${propertyIdx}`,
					$target: resolveTarget(
						objectMap,
						currentTarget,
						propertyPath.PropertyPath,
						false,
						false,
						annotationType,
						annotationsTerm
					)
				};
			});
		case "Path":
			return collectionDefinition.map(pathValue => {
				const $target = resolveTarget(
					objectMap,
					currentTarget,
					pathValue.Path,
					true,
					false,
					annotationType,
					annotationsTerm
				);
				const path = new Path(pathValue, $target, annotationsTerm, annotationType, "");
				toResolve.push({
					inline: isAnnotationPath(pathValue.Path),
					toResolve: path
				});
				return path;
			});
		case "AnnotationPath":
			return collectionDefinition.map((annotationPath, annotationIdx) => {
				const annotationTarget = resolveTarget(
					objectMap,
					currentTarget,
					annotationPath.AnnotationPath,
					true,
					false,
					annotationType,
					annotationsTerm
				);
				const annotationCollectionElement = {
					type: "AnnotationPath",
					value: annotationPath.AnnotationPath,
					fullyQualifiedName: `${parentFQN}/${annotationIdx}`,
					$target: annotationTarget,
					annotationType: annotationType,
					annotationsTerm: annotationsTerm,
					term: "",
					path: ""
				};
				toResolve.push({
					inline: false,
					toResolve: annotationCollectionElement
				});
				return annotationCollectionElement;
			});
		case "NavigationPropertyPath":
			return collectionDefinition.map((navPropertyPath, navPropIdx) => {
				return {
					type: "NavigationPropertyPath",
					value: navPropertyPath.NavigationPropertyPath,
					fullyQualifiedName: `${parentFQN}/${navPropIdx}`,
					$target: resolveTarget(
						objectMap,
						currentTarget,
						navPropertyPath.NavigationPropertyPath,
						false,
						false,
						annotationType,
						annotationsTerm
					)
				};
			});
		case "Record":
			return collectionDefinition.map((recordDefinition, recordIdx) => {
				return parseRecord(
					recordDefinition,
					`${parentFQN}/${recordIdx}`,
					parserOutput,
					currentTarget,
					objectMap,
					toResolve,
					annotationSource,
					unresolvedAnnotations,
					annotationType,
					annotationsTerm
				);
			});
		case "Apply":
		case "If":
		case "Eq":
		case "Ne":
		case "Lt":
		case "Gt":
		case "Le":
		case "Ge":
		case "Not":
		case "And":
		case "Or":
			return collectionDefinition.map(ifValue => {
				return ifValue;
			});
		case "String":
			return collectionDefinition.map(stringValue => {
				if (typeof stringValue === "string") {
					return stringValue;
				} else if (stringValue === undefined) {
					return stringValue;
				} else {
					return stringValue.String;
				}
			});
		default:
			if (collectionDefinition.length === 0) {
				return [];
			}
			throw new Error("Unsupported case");
	}
}

type Resolveable = {
	inline: boolean;
	toResolve: {
		$target: string;
		targetString?: string;
		annotationsTerm: string;
		annotationType: string;
		term: string;
		path: string;
	};
};

function convertAnnotation(
	annotation: Annotation,
	parserOutput: ParserOutput,
	currentTarget: any,
	objectMap: any,
	toResolve: Resolveable[],
	annotationSource: string,
	unresolvedAnnotations: AnnotationList[]
): any {
	if (annotation.record) {
		const annotationType = annotation.record.type
			? unalias(parserOutput.references, annotation.record.type)
			: inferTypeFromTerm(annotation.term, parserOutput, currentTarget.fullyQualifiedName);
		const annotationTerm: any = {
			$Type: annotationType,
			fullyQualifiedName: annotation.fullyQualifiedName,
			qualifier: annotation.qualifier
		};
		const annotationContent: any = {};
		annotation.record.propertyValues.forEach((propertyValue: PropertyValue) => {
			annotationContent[propertyValue.name] = parseValue(
				propertyValue.value,
				`${annotation.fullyQualifiedName}/${propertyValue.name}`,
				parserOutput,
				currentTarget,
				objectMap,
				toResolve,
				annotationSource,
				unresolvedAnnotations,
				annotationType,
				annotation.term
			);
			if (
				annotationContent.hasOwnProperty("Action") &&
				(!annotation.record ||
					annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" ||
					annotationTerm.$Type === "com.sap.vocabularies.UI.v1.DataFieldWithAction")
			) {
				annotationContent.ActionTarget =
					(currentTarget.actions && currentTarget.actions[annotationContent.Action]) ||
					objectMap[annotationContent.Action];
				if (!annotationContent.ActionTarget) {
					ANNOTATION_ERRORS.push({
						message:
							"Unable to resolve the action " +
							annotationContent.Action +
							" defined for " +
							annotation.fullyQualifiedName
					});
					// Add to diagnostics
					// debugger;
				}
			}
		});
		return Object.assign(annotationTerm, annotationContent);
	} else if (annotation.collection === undefined) {
		if (annotation.value) {
			return parseValue(
				annotation.value,
				annotation.fullyQualifiedName,
				parserOutput,
				currentTarget,
				objectMap,
				toResolve,
				annotationSource,
				unresolvedAnnotations,
				"",
				annotation.term
			);
		} else {
			return true;
		}
	} else if (annotation.collection) {
		const collection: any = parseCollection(
			annotation.collection,
			annotation.fullyQualifiedName,
			parserOutput,
			currentTarget,
			objectMap,
			toResolve,
			annotationSource,
			unresolvedAnnotations,
			"",
			annotation.term
		);
		collection.fullyQualifiedName = annotation.fullyQualifiedName;
		return collection;
	} else {
		throw new Error("Unsupported case");
	}
}

function createResolvePathFn(entityType: EntityType, objectMap: Record<string, any>) {
	return function(relativePath: string, includeVisitedObjects: boolean): any {
		const annotationTerm: string = "";
		const annotationType: string = "";
		return resolveTarget(
			objectMap,
			entityType,
			relativePath,
			false,
			includeVisitedObjects,
			annotationType,
			annotationTerm
		);
	};
}

function resolveNavigationProperties(
	entityTypes: ParserEntityType[],
	associations: Association[],
	objectMap: Record<string, any>
): void {
	entityTypes.forEach(entityType => {
		entityType.navigationProperties = entityType.navigationProperties.map(navProp => {
			const outNavProp: Partial<NavigationProperty> = {
				_type: "NavigationProperty",
				name: navProp.name,
				fullyQualifiedName: navProp.fullyQualifiedName,
				partner: (navProp as any).hasOwnProperty("partner") ? (navProp as any).partner : undefined,
				// targetTypeName: FullyQualifiedName;
				// targetType: EntityType;
				isCollection: (navProp as any).hasOwnProperty("isCollection") ? (navProp as any).isCollection : false,
				containsTarget: (navProp as any).hasOwnProperty("containsTarget")
					? (navProp as any).containsTarget
					: false,
				referentialConstraint: (navProp as any).referentialConstraint
					? (navProp as any).referentialConstraint
					: [],
				annotations: {}
			};
			if ((navProp as GenericNavigationProperty).targetTypeName) {
				outNavProp.targetType = objectMap[(navProp as V4NavigationProperty).targetTypeName];
			} else if ((navProp as V2NavigationProperty).relationship) {
				const targetAssociation = associations.find(
					association => association.fullyQualifiedName === (navProp as V2NavigationProperty).relationship
				);
				if (targetAssociation) {
					const associationEnd = targetAssociation.associationEnd.find(
						end => end.role === (navProp as V2NavigationProperty).toRole
					);
					if (associationEnd) {
						outNavProp.targetType = objectMap[associationEnd.type];
						outNavProp.isCollection = associationEnd.multiplicity === "*";
					}
				}
			}
			if (outNavProp.targetType) {
				outNavProp.targetTypeName = outNavProp.targetType.fullyQualifiedName;
			}
			const outNavPropReq = outNavProp as NavigationProperty;
			objectMap[outNavPropReq.fullyQualifiedName] = outNavPropReq;
			return outNavPropReq;
		});
		(entityType as EntityType).resolvePath = createResolvePathFn(entityType as EntityType, objectMap);
	});
}

function linkActionsToEntityType(namespace: string, actions: Action[], objectMap: Record<string, any>): void {
	actions.forEach(action => {
		if (!action.annotations) {
			action.annotations = {};
		}
		if (action.isBound) {
			const sourceEntityType = objectMap[action.sourceType];
			action.sourceEntityType = sourceEntityType;
			if (sourceEntityType) {
				if (!sourceEntityType.actions) {
					sourceEntityType.actions = {};
				}
				sourceEntityType.actions[action.name] = action;
				sourceEntityType.actions[`${namespace}.${action.name}`] = action;
			}
			action.returnEntityType = objectMap[action.returnType];
		}
	});
}

function linkEntityTypeToEntitySet(
	entitySets: EntitySet[],
	objectMap: Record<string, any>,
	references: ReferencesWithMap
): void {
	entitySets.forEach(entitySet => {
		entitySet.entityType = objectMap[entitySet.entityTypeName];
		if (!entitySet.entityType) {
			entitySet.entityType = objectMap[unalias(references, entitySet.entityTypeName) as string];
		}
		if (!entitySet.annotations) {
			entitySet.annotations = {};
		}
		if (!entitySet.entityType.annotations) {
			entitySet.entityType.annotations = {};
		}
		entitySet.entityType.keys.forEach((keyProp: Property) => {
			keyProp.isKey = true;
		});
	});
}

function linkPropertiesToComplexTypes(entityTypes: EntityType[], objectMap: Record<string, any>) {
	entityTypes.forEach(entityType => {
		entityType.entityProperties.forEach(entityProperty => {
			if (!entityProperty.annotations) {
				entityProperty.annotations = {};
			}
			if (entityProperty.type.indexOf("Edm") === -1) {
				if (entityProperty.type.startsWith("Collection")) {
					const complexTypeName = entityProperty.type.substr(11, entityProperty.type.length - 12);
					const complexType = objectMap[complexTypeName] as ComplexType;
					if (complexType) {
						(entityProperty as Property).targetType = complexType;
					}
				} else {
					const complexType = objectMap[entityProperty.type] as ComplexType;
					if (complexType) {
						(entityProperty as Property).targetType = complexType;
					}
				}
			}
		});
	});
}

function prepareComplexTypes(
	complexTypes: ParserComplexType[],
	associations: Association[],
	objectMap: Record<string, any>
) {
	complexTypes.forEach(complexType => {
		(complexType as ComplexType).annotations = {};
		complexType.properties.forEach(property => {
			if (!(property as Property).annotations) {
				(property as Property).annotations = {};
			}
		});
		complexType.navigationProperties = complexType.navigationProperties.map(navProp => {
			if (!(navProp as NavigationProperty).annotations) {
				(navProp as NavigationProperty).annotations = {};
			}
			const outNavProp: Partial<NavigationProperty> = {
				_type: "NavigationProperty",
				name: navProp.name,
				fullyQualifiedName: navProp.fullyQualifiedName,
				partner: (navProp as any).hasOwnProperty("partner") ? (navProp as any).partner : undefined,
				// targetTypeName: FullyQualifiedName;
				// targetType: EntityType;
				isCollection: (navProp as any).hasOwnProperty("isCollection") ? (navProp as any).isCollection : false,
				containsTarget: (navProp as any).hasOwnProperty("containsTarget")
					? (navProp as any).containsTarget
					: false,
				referentialConstraint: (navProp as any).referentialConstraint
					? (navProp as any).referentialConstraint
					: []
			};
			if ((navProp as GenericNavigationProperty).targetTypeName) {
				outNavProp.targetType = objectMap[(navProp as V4NavigationProperty).targetTypeName];
			} else if ((navProp as V2NavigationProperty).relationship) {
				const targetAssociation = associations.find(
					association => association.fullyQualifiedName === (navProp as V2NavigationProperty).relationship
				);
				if (targetAssociation) {
					const associationEnd = targetAssociation.associationEnd.find(
						end => end.role === (navProp as V2NavigationProperty).toRole
					);
					if (associationEnd) {
						outNavProp.targetType = objectMap[associationEnd.type];
						outNavProp.isCollection = associationEnd.multiplicity === "*";
					}
				}
			}
			if (outNavProp.targetType) {
				outNavProp.targetTypeName = outNavProp.targetType.fullyQualifiedName;
			}
			const outNavPropReq = outNavProp as NavigationProperty;
			objectMap[outNavPropReq.fullyQualifiedName] = outNavPropReq;
			return outNavPropReq;
		});
	});
}

function splitTerm(references: ReferencesWithMap, termValue: string) {
	const aliasedTerm = alias(references, termValue);
	const lastDot = aliasedTerm.lastIndexOf(".");
	let termAlias = aliasedTerm.substr(0, lastDot);
	let term = aliasedTerm.substr(lastDot + 1);
	return [termAlias, term];
}

/**
 * Resolve a specific path
 * @param sPath
 */
function createGlobalResolve(convertedOutput: ConverterOutput, objectMap: Record<string, any>) {
	return function resolvePath<T extends ServiceObjectAndAnnotation>(sPath: string): ResolutionTarget<T> {
		const aPathSplit = sPath.split("/");
		if (aPathSplit.shift() !== "") {
			throw new Error("Cannot deal with relative path");
		}
		const entitySetName = aPathSplit.shift();
		const entitySet = convertedOutput.entitySets.find(et => et.name === entitySetName);
		if (!entitySet) {
			return {
				target: convertedOutput.entityContainer,
				objectPath: [convertedOutput.entityContainer]
			} as ResolutionTarget<T>;
		}
		if (aPathSplit.length === 0) {
			return {
				target: entitySet,
				objectPath: [convertedOutput.entityContainer, entitySet]
			} as ResolutionTarget<T>;
		} else {
			const targetResolution: any = resolveTarget(objectMap, entitySet, "/" + aPathSplit.join("/"), false, true);
			if (targetResolution.target) {
				targetResolution.visitedObjects.push(targetResolution.target);
			}
			return {
				target: targetResolution.target,
				objectPath: targetResolution.visitedObjects
			};
		}
	};
}

let ANNOTATION_ERRORS: { message: string }[] = [];
let ALL_ANNOTATION_ERRORS: any = {};

export function convertTypes(parserOutput: ParserOutput): ConverterOutput {
	ANNOTATION_ERRORS = [];
	const objectMap = buildObjectMap(parserOutput);
	resolveNavigationProperties(
		parserOutput.schema.entityTypes as EntityType[],
		parserOutput.schema.associations,
		objectMap
	);
	if (!(parserOutput.schema.entityContainer as EntityContainer).annotations) {
		(parserOutput.schema.entityContainer as EntityContainer).annotations = {};
	}
	linkActionsToEntityType(parserOutput.schema.namespace, parserOutput.schema.actions as Action[], objectMap);
	linkEntityTypeToEntitySet(parserOutput.schema.entitySets as EntitySet[], objectMap, parserOutput.references);
	linkPropertiesToComplexTypes(parserOutput.schema.entityTypes as EntityType[], objectMap);
	prepareComplexTypes(parserOutput.schema.complexTypes as ComplexType[], parserOutput.schema.associations, objectMap);
	const toResolve: Resolveable[] = [];
	const unresolvedAnnotations: AnnotationList[] = [];

	Object.keys(parserOutput.schema.annotations).forEach(annotationSource => {
		parserOutput.schema.annotations[annotationSource].forEach(annotationList => {
			const currentTargetName = unalias(parserOutput.references, annotationList.target) as string;
			const currentTarget = objectMap[currentTargetName];
			if (!currentTarget) {
				if (currentTargetName && currentTargetName.indexOf("@") !== -1) {
					(annotationList as any).__source = annotationSource;
					unresolvedAnnotations.push(annotationList);
				}
			} else if (typeof currentTarget === "object") {
				if (!currentTarget.annotations) {
					currentTarget.annotations = {};
				}
				annotationList.annotations.forEach(annotation => {
					const [vocAlias, vocTerm] = splitTerm(defaultReferences, annotation.term);
					if (!currentTarget.annotations[vocAlias]) {
						currentTarget.annotations[vocAlias] = {};
					}
					if (!currentTarget.annotations._annotations) {
						currentTarget.annotations._annotations = {};
					}

					const vocTermWithQualifier = `${vocTerm}${annotation.qualifier ? `#${annotation.qualifier}` : ""}`;
					currentTarget.annotations[vocAlias][vocTermWithQualifier] = convertAnnotation(
						annotation as Annotation,
						parserOutput,
						currentTarget,
						objectMap,
						toResolve,
						annotationSource,
						unresolvedAnnotations
					);
					switch (typeof currentTarget.annotations[vocAlias][vocTermWithQualifier]) {
						case "string":
							currentTarget.annotations[vocAlias][vocTermWithQualifier] = new String(
								currentTarget.annotations[vocAlias][vocTermWithQualifier]
							);
							break;
						case "boolean":
							currentTarget.annotations[vocAlias][vocTermWithQualifier] = new Boolean(
								currentTarget.annotations[vocAlias][vocTermWithQualifier]
							);
							break;
					}
					if (
						currentTarget.annotations[vocAlias][vocTermWithQualifier] !== null &&
						typeof currentTarget.annotations[vocAlias][vocTermWithQualifier] === "object"
					) {
						currentTarget.annotations[vocAlias][vocTermWithQualifier].term = unalias(
							defaultReferences,
							`${vocAlias}.${vocTerm}`
						);
						currentTarget.annotations[vocAlias][vocTermWithQualifier].qualifier = annotation.qualifier;
						currentTarget.annotations[vocAlias][vocTermWithQualifier].__source = annotationSource;
					}
					const annotationTarget = `${currentTargetName}@${unalias(
						defaultReferences,
						vocAlias + "." + vocTermWithQualifier
					)}`;
					if (annotation.annotations && Array.isArray(annotation.annotations)) {
						const subAnnotationList = {
							target: annotationTarget,
							annotations: annotation.annotations,
							__source: annotationSource
						};
						unresolvedAnnotations.push(subAnnotationList);
					} else if (
						annotation.annotations &&
						!currentTarget.annotations[vocAlias][vocTermWithQualifier].annotations
					) {
						currentTarget.annotations[vocAlias][vocTermWithQualifier].annotations = annotation.annotations;
					}
					currentTarget.annotations._annotations[`${vocAlias}.${vocTermWithQualifier}`] =
						currentTarget.annotations[vocAlias][vocTermWithQualifier];
					objectMap[annotationTarget] = currentTarget.annotations[vocAlias][vocTermWithQualifier];
				});
			}
		});
	});
	const extraUnresolvedAnnotations: AnnotationList[] = [];
	unresolvedAnnotations.forEach(annotationList => {
		const currentTargetName = unalias(parserOutput.references, annotationList.target) as string;
		let [baseObj, annotationPart] = currentTargetName.split("@");
		const targetSplit = annotationPart.split("/");
		baseObj = baseObj + "@" + targetSplit[0];
		const currentTarget = targetSplit.slice(1).reduce((currentObj, path) => {
			if (!currentObj) {
				return null;
			}
			return currentObj[path];
		}, objectMap[baseObj]);
		if (!currentTarget) {
			ANNOTATION_ERRORS.push({
				message: "The following annotation target was not found on the service " + currentTargetName
			});
			// console.log("Missing target again " + currentTargetName);
		} else if (typeof currentTarget === "object") {
			if (!currentTarget.annotations) {
				currentTarget.annotations = {};
			}
			annotationList.annotations.forEach(annotation => {
				const [vocAlias, vocTerm] = splitTerm(defaultReferences, annotation.term);
				if (!currentTarget.annotations[vocAlias]) {
					currentTarget.annotations[vocAlias] = {};
				}
				if (!currentTarget.annotations._annotations) {
					currentTarget.annotations._annotations = {};
				}

				const vocTermWithQualifier = `${vocTerm}${annotation.qualifier ? `#${annotation.qualifier}` : ""}`;
				currentTarget.annotations[vocAlias][vocTermWithQualifier] = convertAnnotation(
					annotation as Annotation,
					parserOutput,
					currentTarget,
					objectMap,
					toResolve,
					(annotationList as any).__source,
					extraUnresolvedAnnotations
				);
				if (
					currentTarget.annotations[vocAlias][vocTermWithQualifier] !== null &&
					typeof currentTarget.annotations[vocAlias][vocTermWithQualifier] === "object"
				) {
					currentTarget.annotations[vocAlias][vocTermWithQualifier].term = unalias(
						defaultReferences,
						`${vocAlias}.${vocTerm}`
					);
					currentTarget.annotations[vocAlias][vocTermWithQualifier].qualifier = annotation.qualifier;
					currentTarget.annotations[vocAlias][
						vocTermWithQualifier
					].__source = (annotationList as any).__source;
				}
				currentTarget.annotations._annotations[`${vocAlias}.${vocTermWithQualifier}`] =
					currentTarget.annotations[vocAlias][vocTermWithQualifier];
				objectMap[`${currentTargetName}@${unalias(defaultReferences, vocAlias + "." + vocTermWithQualifier)}`] =
					currentTarget.annotations[vocAlias][vocTermWithQualifier];
			});
		}
	});
	toResolve.forEach(resolveable => {
		const toResolve = resolveable.toResolve;
		const targetStr = toResolve.$target;
		const resolvedTarget = objectMap[targetStr];
		const { annotationsTerm, annotationType } = toResolve;
		delete toResolve.annotationType;
		delete toResolve.annotationsTerm;

		if (resolveable.inline) {
			// inline the resolved target
			let keys: keyof typeof toResolve;
			for (keys in toResolve) delete toResolve[keys];

			Object.assign(toResolve, resolvedTarget);
		} else {
			// assign the resolved target
			toResolve.$target = resolvedTarget;
		}

		if (!resolvedTarget) {
			toResolve.targetString = targetStr;
			if (annotationsTerm && annotationType) {
				const oErrorMsg = {
					message:
						"Unable to resolve the path expression: " +
						targetStr +
						"\n" +
						"\n" +
						"Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n" +
						"<Annotation Term = " +
						annotationsTerm +
						">" +
						"\n" +
						"<Record Type = " +
						annotationType +
						">" +
						"\n" +
						"<AnnotationPath = " +
						targetStr +
						">"
				};
				addAnnotationErrorMessage(targetStr, oErrorMsg);
			} else {
				const property = toResolve.term;
				const path = toResolve.path;
				const termInfo = targetStr ? targetStr.split("/")[0] : targetStr;
				const oErrorMsg = {
					message:
						"Unable to resolve the path expression: " +
						targetStr +
						"\n" +
						"\n" +
						"Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n" +
						"<Annotation Term = " +
						termInfo +
						">" +
						"\n" +
						"<PropertyValue Property = " +
						property +
						"        Path= " +
						path +
						">"
				};
				addAnnotationErrorMessage(targetStr, oErrorMsg);
			}
		}
	});
	for (var property in ALL_ANNOTATION_ERRORS) {
		ANNOTATION_ERRORS.push(ALL_ANNOTATION_ERRORS[property][0]);
	}
	(parserOutput as any).entitySets = parserOutput.schema.entitySets;

	const convertedOutput: Partial<ConverterOutput> = {
		version: parserOutput.version,
		annotations: parserOutput.schema.annotations,
		namespace: parserOutput.schema.namespace,
		entityContainer: parserOutput.schema.entityContainer as EntityContainer,
		actions: parserOutput.schema.actions as Action[],
		entitySets: parserOutput.schema.entitySets as EntitySet[],
		entityTypes: parserOutput.schema.entityTypes as EntityType[],
		complexTypes: parserOutput.schema.complexTypes as ComplexType[],
		references: defaultReferences,
		diagnostics: ANNOTATION_ERRORS.concat()
	};
	convertedOutput.resolvePath = createGlobalResolve(convertedOutput as ConverterOutput, objectMap);
	return convertedOutput as ConverterOutput;
}

function revertValueToGenericType(references: Reference[], value: any): Expression | undefined {
	let result: Expression | undefined;
	if (typeof value === "string") {
		const valueMatches = value.match(/(\w+)\.\w+\/.*/);
		if (valueMatches && references.find(ref => ref.alias === valueMatches[1])) {
			result = {
				type: "EnumMember",
				EnumMember: value
			};
		} else {
			result = {
				type: "String",
				String: value
			};
		}
	} else if (Array.isArray(value)) {
		result = {
			type: "Collection",
			Collection: value.map(anno => revertCollectionItemToGenericType(references, anno)) as any[]
		};
	} else if (typeof value === "boolean") {
		result = {
			type: "Bool",
			Bool: value
		};
	} else if (typeof value === "number") {
		if (value.toString() === value.toFixed()) {
			result = {
				type: "Int",
				Int: value
			};
		} else {
			result = {
				type: "Decimal",
				Decimal: value
			};
		}
	} else if (typeof value === "object" && value.isDecimal && value.isDecimal()) {
		result = {
			type: "Decimal",
			Decimal: value.valueOf()
		};
	} else if (value.type === "Path") {
		result = {
			type: "Path",
			Path: value.path
		};
	} else if (value.type === "AnnotationPath") {
		result = {
			type: "AnnotationPath",
			AnnotationPath: value.value
		};
	} else if (value.type === "PropertyPath") {
		result = {
			type: "PropertyPath",
			PropertyPath: value.value
		};
	} else if (value.type === "NavigationPropertyPath") {
		result = {
			type: "NavigationPropertyPath",
			NavigationPropertyPath: value.value
		};
	} else if (Object.prototype.hasOwnProperty.call(value, "$Type")) {
		result = {
			type: "Record",
			Record: revertCollectionItemToGenericType(references, value) as AnnotationRecord
		};
	}
	return result;
}

function revertCollectionItemToGenericType(
	references: Reference[],
	collectionItem: any
):
	| AnnotationRecord
	| string
	| PropertyPathExpression
	| PathExpression
	| NavigationPropertyPathExpression
	| AnnotationPathExpression
	| undefined {
	if (typeof collectionItem === "string") {
		return collectionItem;
	} else if (typeof collectionItem === "object") {
		if (collectionItem.hasOwnProperty("$Type")) {
			// Annotation Record
			const outItem: AnnotationRecord = {
				type: collectionItem.$Type,
				propertyValues: [] as any[]
			};
			// Could validate keys and type based on $Type
			Object.keys(collectionItem).forEach(collectionKey => {
				if (
					collectionKey !== "$Type" &&
					collectionKey !== "term" &&
					collectionKey !== "__source" &&
					collectionKey !== "qualifier" &&
					collectionKey !== "ActionTarget" &&
					collectionKey !== "fullyQualifiedName" &&
					collectionKey !== "annotations"
				) {
					const value = collectionItem[collectionKey];
					outItem.propertyValues.push({
						name: collectionKey,
						value: revertValueToGenericType(references, value) as Expression
					});
				} else if (collectionKey === "annotations") {
					const annotations = collectionItem[collectionKey];
					outItem.annotations = [];
					Object.keys(annotations)
						.filter(key => key !== "_annotations")
						.forEach(key => {
							Object.keys(annotations[key]).forEach(term => {
								const parsedAnnotation = revertTermToGenericType(references, annotations[key][term]);
								if (!parsedAnnotation.term) {
									const unaliasedTerm = unalias(references, `${key}.${term}`);
									if (unaliasedTerm) {
										const qualifiedSplit = unaliasedTerm.split("#");
										parsedAnnotation.term = qualifiedSplit[0];
										if (qualifiedSplit.length > 1) {
											parsedAnnotation.qualifier = qualifiedSplit[1];
										}
									}
								}
								outItem.annotations?.push(parsedAnnotation);
							});
						});
				}
			});
			return outItem;
		} else if (collectionItem.type === "PropertyPath") {
			return {
				type: "PropertyPath",
				PropertyPath: collectionItem.value
			};
		} else if (collectionItem.type === "AnnotationPath") {
			return {
				type: "AnnotationPath",
				AnnotationPath: collectionItem.value
			};
		} else if (collectionItem.type === "NavigationPropertyPath") {
			return {
				type: "NavigationPropertyPath",
				NavigationPropertyPath: collectionItem.value
			};
		}
	}
}

export function revertTermToGenericType(references: Reference[], annotation: AnnotationTerm<any>): EdmAnnotation {
	const baseAnnotation: EdmAnnotation = {
		term: annotation.term,
		qualifier: annotation.qualifier
	};
	if (Array.isArray(annotation)) {
		// Collection
		if (annotation.hasOwnProperty("annotations")) {
			baseAnnotation.annotations = [];
			const currentAnnotations = (annotation as any).annotations;
			Object.keys(currentAnnotations)
				.filter(key => key !== "_annotations")
				.forEach(key => {
					Object.keys(currentAnnotations[key]).forEach(term => {
						const parsedAnnotation = revertTermToGenericType(references, currentAnnotations[key][term]);
						if (!parsedAnnotation.term) {
							const unaliasedTerm = unalias(references, `${key}.${term}`);
							if (unaliasedTerm) {
								const qualifiedSplit = unaliasedTerm.split("#");
								parsedAnnotation.term = qualifiedSplit[0];
								if (qualifiedSplit.length > 1) {
									parsedAnnotation.qualifier = qualifiedSplit[1];
								}
							}
						}
						baseAnnotation.annotations?.push(parsedAnnotation);
					});
				});
		}
		return {
			...baseAnnotation,
			collection: annotation.map(anno => revertCollectionItemToGenericType(references, anno)) as any[]
		};
	} else if (annotation.hasOwnProperty("$Type")) {
		return { ...baseAnnotation, record: revertCollectionItemToGenericType(references, annotation) as any };
	} else {
		return { ...baseAnnotation, value: revertValueToGenericType(references, annotation) };
	}
}
