import { EntityType as _EntityType, Action as _Action, Property, NavigationProperty } from "./Converter";
import { RecordAnnotations, TermAnnotations, AnnotationAnnotations } from "./generated/Edm_Types";
export declare type PropertyPath = {
    fullyQualifiedName: string;
    type: "PropertyPath";
    value: string;
    $target: Property;
};
export declare type NavigationPropertyPath = {
    type: "NavigationPropertyPath";
    value: string;
    $target: NavigationProperty;
};
export declare type AnnotationPath<P> = {
    type: "AnnotationPath";
    value: string;
    $target: AnnotationTerm<P>;
};
declare type PrimitiveTypeCast<P, G> = (P extends boolean ? boolean | (Boolean & G) : never) | (P extends number ? number | (Number & G) : never) | (P extends string ? string | (String & G) : never) | (P & G);
export declare type AnnotationTerm<P> = PrimitiveTypeCast<P, {
    fullyQualifiedName: string;
    term: string;
    qualifier: string;
    annotations?: TermAnnotations & AnnotationAnnotations;
}>;
export declare type PathAnnotationExpression<P> = {
    type: "Path";
    path: string;
    $target: P;
    getValue(): P;
};
export declare type ApplyAnnotationExpression<P> = {
    type: "Apply";
    Apply: PropertyAnnotationValue<P>[];
    Function: "odata.concat";
};
export declare type EqConditionalExpression = {
    $Eq: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};
export declare type NeConditionalExpression = {
    $Ne: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};
export declare type GtConditionalExpression = {
    $Gt: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};
export declare type GeConditionalExpression = {
    $Ge: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};
export declare type LtConditionalExpression = {
    $Lt: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};
export declare type LeConditionalExpression = {
    $Le: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};
export declare type AndConditionalExpression = {
    $And: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};
export declare type OrConditionalExpression = {
    $Or: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};
export declare type NotConditionalExpression = {
    $Not: [ConditionalCheckOrValue];
};
export declare type PathConditionExpression<T> = {
    $Path: string;
};
export declare type ConditionalCheck = OrConditionalExpression | AndConditionalExpression | NotConditionalExpression | EqConditionalExpression | NeConditionalExpression | GtConditionalExpression | GeConditionalExpression | LtConditionalExpression | LeConditionalExpression;
export declare type ConditionalCheckOrValue = null | string | number | boolean | ConditionalCheck | PathConditionExpression<string | number | boolean>;
export declare type IfAnnotationExpressionValue<OutType> = [ConditionalCheck, OutType, OutType];
export declare type IfAnnotationExpression<P> = {
    type: "If";
    If: IfAnnotationExpressionValue<P>;
    getValue(): P;
};
export declare type AndAnnotationExpression<P> = {
    type: "And";
    And: AndConditionalExpression[];
};
export declare type OrAnnotationExpression<P> = {
    type: "Or";
    Or: OrConditionalExpression[];
};
export declare type EqAnnotationExpression<P> = {
    type: "Eq";
    Eq: EqConditionalExpression[];
};
export declare type NeAnnotationExpression<P> = {
    type: "Ne";
    Ne: NeConditionalExpression[];
};
export declare type NotAnnotationExpression<P> = {
    type: "Not";
    Not: NotConditionalExpression;
};
export declare type GtAnnotationExpression<P> = {
    type: "Gt";
    Gt: GtConditionalExpression[];
};
export declare type GeAnnotationExpression<P> = {
    type: "Ge";
    Ge: GeConditionalExpression[];
};
export declare type LtAnnotationExpression<P> = {
    type: "Lt";
    Lt: LtConditionalExpression[];
};
export declare type LeAnnotationExpression<P> = {
    type: "Le";
    Le: LeConditionalExpression[];
};
export declare type PropertyAnnotationValue<P> = P | PathAnnotationExpression<P> | ApplyAnnotationExpression<P> | AndAnnotationExpression<P> | OrAnnotationExpression<P> | EqAnnotationExpression<P> | NeAnnotationExpression<P> | NotAnnotationExpression<P> | GtAnnotationExpression<P> | GeAnnotationExpression<P> | LtAnnotationExpression<P> | LeAnnotationExpression<P> | IfAnnotationExpression<P>;
export declare type InstancePath = string;
export declare type Byte = Number;
export declare type Int16 = Number;
export declare type Int32 = Number;
export declare type Int64 = Number;
export declare type Time = string;
export declare type Binary = string;
export declare type Decimal = Number;
export declare type Double = Number;
export declare type Date = string;
export declare type Guid = any;
export declare type Duration = any;
export declare type DateTimeOffset = any;
export declare type GeographyPoint = any;
export declare type PrimitiveType = Binary | Boolean | Byte | Date | DateTimeOffset | Decimal | Double | Duration | Guid | Int16 | Int32 | Int64 | String | GeographyPoint;
export declare type EnumValue<P> = P | PathAnnotationExpression<P> | ApplyAnnotationExpression<P> | IfAnnotationExpression<P>;
export declare type ComplexType = {
    annotations?: RecordAnnotations;
};
export declare type String = InstanceType<StringConstructor>;
export declare type Boolean = InstanceType<BooleanConstructor>;
export declare type EntityType = _EntityType;
export declare type Action = _Action;
export {};
