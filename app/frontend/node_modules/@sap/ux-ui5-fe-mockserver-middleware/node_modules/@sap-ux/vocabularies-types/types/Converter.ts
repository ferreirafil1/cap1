import {
	Property as ParserProperty,
	EntityType as ParserEntityType,
	EntitySet as ParserEntitySet,
	Action as ParserAction,
	ComplexType as ParserComplexType,
	EntityContainer as ParserEntityContainer,
	Reference,
	ReferentialConstraint
} from "./Parser";

import { Annotation as EdmAnnotation, AnnotationList, FullyQualifiedName, SimpleIdentifier } from "./BaseEdm";
import {
	ActionAnnotations,
	ActionImportAnnotations,
	AnnotationAnnotations,
	ComplexTypeAnnotations,
	EntityContainerAnnotations,
	EntitySetAnnotations,
	EntityTypeAnnotations,
	EnumTypeAnnotations,
	FunctionAnnotations,
	FunctionImportAnnotations,
	IncludeAnnotations,
	NavigationPropertyAnnotations,
	ParameterAnnotations,
	PropertyAnnotations,
	ReferenceAnnotations,
	ReturnTypeAnnotations,
	SchemaAnnotations,
	SingletonAnnotations,
	TermAnnotations,
	TypeDefinitionAnnotations,
	PropertyValueAnnotations,
	RecordAnnotations
} from "./generated/Edm_Types";

export type AnyAnnotation =
	| EnumTypeAnnotations
	| PropertyValueAnnotations
	| IncludeAnnotations
	| ReferenceAnnotations
	| ActionAnnotations
	| FunctionImportAnnotations
	| ActionImportAnnotations
	| TypeDefinitionAnnotations
	| SingletonAnnotations
	| EntityContainerAnnotations
	| FunctionAnnotations
	| ReturnTypeAnnotations
	| ParameterAnnotations
	| ComplexTypeAnnotations
	| TermAnnotations
	| RecordAnnotations
	| SchemaAnnotations
	| AnnotationAnnotations
	| EntitySetAnnotations
	| EntityTypeAnnotations
	| PropertyAnnotations
	| NavigationPropertyAnnotations;

export type Property = ParserProperty & {
	annotations: PropertyAnnotations;
	targetType?: ComplexType;
	isKey: boolean;
};

export type ComplexType = Omit<ParserComplexType, "properties" | "navigationProperties" | "_type"> & {
	_type: "ComplexType";
	properties: Property[];
	navigationProperties: NavigationProperty[];
	annotations: ComplexTypeAnnotations;
};

export type NavigationProperty = {
	_type: "NavigationProperty";
	name: SimpleIdentifier;
	partner: string;
	fullyQualifiedName: FullyQualifiedName;
	targetTypeName: FullyQualifiedName;
	targetType: EntityType;
	annotations: NavigationPropertyAnnotations;
	isCollection: boolean;
	containsTarget: boolean;
	referentialConstraint?: ReferentialConstraint[];
};

export type EntityType = Omit<ParserEntityType, "entityProperties" | "navigationProperties" | "keys" | "_type"> & {
	_type: "EntityType";
	entityProperties: Property[];
	keys: Property[];
	navigationProperties: NavigationProperty[];
	actions: Record<string, Action>;
	annotations: EntityTypeAnnotations;
	resolvePath(relativePath: string, includeVisitedObjects?: boolean): any;
};

export type EntitySet = Omit<ParserEntitySet, "entityType" | "_type"> & {
	_type: "EntitySet";
	entityType: EntityType;
	navigationPropertyBinding: Record<string, EntitySet>;
	annotations: EntitySetAnnotations;
};

export type EntityContainer = ParserEntityContainer & {
	_type: "EntityContainer";
	annotations: EntityContainerAnnotations;
};

export type Action = ParserAction & {
	_type: "Action";
	sourceEntityType?: EntityType;
	returnEntityType?: EntityType;
	annotations: ActionAnnotations;
	parameters: {
		_type: "ActionParameter";
		isEntitySet: boolean;
		fullyQualifiedName: string;
		type: string;
		annotations: ParameterAnnotations;
	}[];
};

export type ServiceObject =
	| EntitySet
	| EntityType
	| Property
	| ComplexType
	| NavigationProperty
	| Action
	| EntityContainer;
export type ServiceObjectAndAnnotation = ServiceObject | AnyAnnotation;

export type Annotation = EdmAnnotation & {
	fullyQualifiedName: string;
};

export type ResolutionTarget<T> = {
	target: null | T;
	objectPath: ServiceObjectAndAnnotation[];
};

export type ConverterOutput = {
	version: string;
	annotations: Record<string, AnnotationList[]>;
	namespace: string;
	actions: Action[];
	entityContainer: EntityContainer;
	complexTypes: ComplexType[];
	entitySets: EntitySet[];
	entityTypes: EntityType[];
	references: Reference[];
	diagnostics: { message: string }[];
	resolvePath: <T>(path: string) => ResolutionTarget<T>;
};

export function Decimal(value: number) {
	return {
		isDecimal() {
			return true;
		},
		valueOf() {
			return value;
		},
		toString() {
			return value.toString();
		}
	};
}
