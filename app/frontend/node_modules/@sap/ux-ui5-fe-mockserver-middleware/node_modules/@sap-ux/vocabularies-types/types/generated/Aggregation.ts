import * as Core from "./Core";
import * as Capabilities from "./Capabilities";
import * as Edm from "../Edm";
import AnnotationTerm = Edm.AnnotationTerm;
import PropertyAnnotationValue = Edm.PropertyAnnotationValue;
import EnumValue = Edm.EnumValue;
import ComplexType = Edm.ComplexType;

// Term
/**
  This structured type, entity set or entity container supports the $apply system query option
*/
export type ApplySupported = AnnotationTerm<ApplySupportedTypeTypes>;

// ComplexType
export type ApplySupportedType = ComplexType & {
	$Type: AggregationAnnotationTypes.ApplySupportedType;
	/**
        Transformations that can be used in `$apply`
    */
	Transformations: PropertyAnnotationValue<Edm.String[]>;
	/**
        Qualified names of custom aggregation methods that can be used in `aggregate(...with...)`
    */
	CustomAggregationMethods: PropertyAnnotationValue<Edm.String[]>;
	/**
        The service supports rollup hierarchies in a `groupby` transformation
    */
	Rollup: RollupType;
	/**
        Only properties marked as `Groupable` can be used in the `groupby` transformation, and only those marked as `Aggregatable` can be used in the  `aggregate` transformation
    */
	PropertyRestrictions: PropertyAnnotationValue<Edm.Boolean>;
	/**
        A non-empty collection indicates that only the listed properties of the annotated target are supported by the `groupby` transformation
    */
	GroupableProperties: PropertyAnnotationValue<Edm.PropertyPath[]>;
	/**
        A non-empty collection indicates that only the listed properties of the annotated target can be used in the `aggregate` transformation, optionally restricted to the specified aggregation methods
    */
	AggregatableProperties: AnnotationTerm<AggregatablePropertyTypeTypes[]>;
};

// ComplexType
export type AggregatablePropertyType = ComplexType & {
	$Type: AggregationAnnotationTypes.AggregatablePropertyType;
	/**
        Aggregatable property
    */
	Property: PropertyAnnotationValue<Edm.PropertyPath>;
	/**
        Standard and custom aggregation methods than can be applied to the property. If omitted, all aggregation methods can be applied
    */
	SupportedAggregationMethods: PropertyAnnotationValue<Edm.String[]>;
	/**
        Recommended method for aggregating values of the property
    */
	RecommendedAggregationMethod?: PropertyAnnotationValue<Edm.String>;
};

// EnumType
/**
  The number of `rollup` operators allowed in a `groupby` transformation
*/
export const enum RollupType {
	/**
	No `rollup` support
    */
	/**
	undefined
    */
	None = "Aggregation.RollupType/None",
	/**
	Only one `rollup` operator per `groupby`
    */
	/**
	undefined
    */
	SingleHierarchy = "Aggregation.RollupType/SingleHierarchy",
	/**
	Full `rollup` support
    */
	/**
	undefined
    */
	MultipleHierarchies = "Aggregation.RollupType/MultipleHierarchies"
}

// Term
/**
  This property can be used in the `groupby` transformation
*/
export type Groupable = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  This property can be used in the `aggregate` transformation
*/
export type Aggregatable = AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;

// Term
/**
  Dynamic property that can be used in the `aggregate` transformation
*/
export type CustomAggregate = AnnotationTerm<PropertyAnnotationValue<Edm.String>>;

// Term
/**
  The annotated property or custom aggregate is only well-defined in the context of these properties
*/
export type ContextDefiningProperties = AnnotationTerm<Edm.PropertyPath[]>;

// Term
/**
  Defines a leveled hierarchy by defining an ordered list of properties in the hierarchy
*/
export type LeveledHierarchy = AnnotationTerm<Edm.PropertyPath[]>;

// Term
/**
  Defines a recursive hierarchy.
*/
export type RecursiveHierarchy = AnnotationTerm<RecursiveHierarchyTypeTypes>;

// ComplexType
export type RecursiveHierarchyType = ComplexType & {
	$Type: AggregationAnnotationTypes.RecursiveHierarchyType;
	/**
        Property holding the hierarchy node value
    */
	NodeProperty: PropertyAnnotationValue<Edm.PropertyPath>;
	/**
        Property for navigating to the parent node
    */
	ParentNavigationProperty: PropertyAnnotationValue<Edm.NavigationPropertyPath>;
	/**
        Property holding the number of edges between the node and the root node
    */
	DistanceFromRootProperty?: PropertyAnnotationValue<Edm.PropertyPath>;
	/**
        Property indicating whether the node is a leaf of the hierarchy
    */
	IsLeafProperty?: PropertyAnnotationValue<Edm.PropertyPath>;
};

/**
  Returns true, if and only if the value of the node property of the specified hierarchy is the root of the hierarchy
*/
export type isroot = (Entity: Edm.EntityType, Hierarchy: any) => Edm.Boolean;
/**
  Returns true, if and only if the value of the node property of the specified hierarchy is a descendant of the given parent node with a distance of less than or equal to the optionally specified maximum distance
*/
export type isdescendant = (
	Entity: Edm.EntityType,
	Hierarchy: any,
	Node: Edm.PrimitiveType,
	MaxDistance: Edm.Int16
) => Edm.Boolean;
/**
  Returns true, if and only if the value of the node property of the specified hierarchy is an ancestor of the given child node with a distance of less than or equal to the optionally specified maximum distance
*/
export type isancestor = (
	Entity: Edm.EntityType,
	Hierarchy: any,
	Node: Edm.PrimitiveType,
	MaxDistance: Edm.Int16
) => Edm.Boolean;
/**
  Returns true, if and only if the value of the node property of the specified hierarchy has the same parent node as the specified node
*/
export type issibling = (Entity: Edm.EntityType, Hierarchy: any, Node: Edm.PrimitiveType) => Edm.Boolean;
/**
  Returns true, if and only if the value of the node property of the specified hierarchy has no descendants
*/
export type isleaf = (Entity: Edm.EntityType, Hierarchy: any) => Edm.Boolean;

// Term
/**
  This action or function is available on aggregated entities if the `RequiredProperties` are still defined
*/
export type AvailableOnAggregates = AnnotationTerm<AvailableOnAggregatesTypeTypes>;

// ComplexType
export type AvailableOnAggregatesType = ComplexType & {
	$Type: AggregationAnnotationTypes.AvailableOnAggregatesType;
	/**
        Properties required to apply this action or function
    */
	RequiredProperties: PropertyAnnotationValue<Edm.PropertyPath[]>;
};

// ComplexType
/**
  Aggregation capabilities on a navigation path
*/
export type NavigationPropertyAggregationCapabilities = ComplexType &
	Omit<Capabilities.NavigationPropertyRestriction, "$Type"> & {
		$Type: AggregationAnnotationTypes.NavigationPropertyAggregationCapabilities;
		/**
        Support for `$apply`
    */
		ApplySupported?: AnnotationTerm<ApplySupportedTypeTypes>;
		/**
        Supported custom aggregates
    */
		CustomAggregates: AnnotationTerm<CustomAggregateTypeTypes[]>;
	};

// ComplexType
export type CustomAggregateType = ComplexType & {
	$Type: AggregationAnnotationTypes.CustomAggregateType;
	/**
        Name of the dynamic property that can be used in the `aggregate` transformation
    */
	Name: PropertyAnnotationValue<Edm.String>;
	/**
        Qualified name of a primitive type. The aggregated value will be of that type
    */
	Type: PropertyAnnotationValue<Edm.String>;
};

export const enum AggregationAnnotationTerms {
	ApplySupported = "Org.OData.Aggregation.V1.ApplySupported",
	Groupable = "Org.OData.Aggregation.V1.Groupable",
	Aggregatable = "Org.OData.Aggregation.V1.Aggregatable",
	CustomAggregate = "Org.OData.Aggregation.V1.CustomAggregate",
	ContextDefiningProperties = "Org.OData.Aggregation.V1.ContextDefiningProperties",
	LeveledHierarchy = "Org.OData.Aggregation.V1.LeveledHierarchy",
	RecursiveHierarchy = "Org.OData.Aggregation.V1.RecursiveHierarchy",
	AvailableOnAggregates = "Org.OData.Aggregation.V1.AvailableOnAggregates"
}
export const enum AggregationAnnotationTypes {
	ApplySupportedType = "Org.OData.Aggregation.V1.ApplySupportedType",
	AggregatablePropertyType = "Org.OData.Aggregation.V1.AggregatablePropertyType",
	RecursiveHierarchyType = "Org.OData.Aggregation.V1.RecursiveHierarchyType",
	AvailableOnAggregatesType = "Org.OData.Aggregation.V1.AvailableOnAggregatesType",
	NavigationPropertyAggregationCapabilities = "Org.OData.Aggregation.V1.NavigationPropertyAggregationCapabilities",
	CustomAggregateType = "Org.OData.Aggregation.V1.CustomAggregateType"
}

export type ApplySupportedTypeTypes = AnnotationTerm<ApplySupportedType>;
export type AggregatablePropertyTypeTypes = AnnotationTerm<AggregatablePropertyType>;
export type RecursiveHierarchyTypeTypes = AnnotationTerm<RecursiveHierarchyType>;
export type AvailableOnAggregatesTypeTypes = AnnotationTerm<AvailableOnAggregatesType>;
export type NavigationPropertyAggregationCapabilitiesTypes = AnnotationTerm<NavigationPropertyAggregationCapabilities>;
export type NavigationPropertyRestrictionTypes = AnnotationTerm<
	Capabilities.NavigationPropertyRestriction | NavigationPropertyAggregationCapabilitiesTypes
>;
export type CustomAggregateTypeTypes = AnnotationTerm<CustomAggregateType>;
