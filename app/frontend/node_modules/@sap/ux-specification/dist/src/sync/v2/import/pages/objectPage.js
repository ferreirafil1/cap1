"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const v2_1 = require("../../../../v2");
const common_1 = require("../../../common");
const table_1 = require("../controls/table");
const extensionLogger_1 = require("../../../../extensionLogger");
const utils_1 = require("../utils");
const common_2 = require("../../../common");
const manifest_1 = require("../../export/manifest");
const sapUiPageV2_1 = require("../.../../../../../specification/v2/webapp/manifest/sapUiPageV2");
const i18next_1 = __importDefault(require("i18next"));
const i18n_1 = require("../../../../i18n/i18n");
const common_3 = require("../../../../specification/common");
const listReport_1 = require("../pages/listReport");
const factory_1 = require("../../export/factory");
/**
 * Prepares the list of flex changes
 * @param change - the flex change (UI Adaptation)
 * @returns {FlexChangesForTransfer} - list of prepared flex changes
 */
function prepareFlexChanges(changes, entitySet, logger) {
    const result = {};
    // To create unique selector Id in case there are multiple change files with same selector ID
    let i = 1;
    changes.forEach((changeString) => {
        var _a, _b;
        try {
            const change = common_2.parseChangeString(changeString);
            if (((_a = change.controlId) === null || _a === void 0 ? void 0 : _a.includes(sapUiPageV2_1.FE_TEMPLATE_V2_OBJECT_PAGE)) && ((_b = change.controlId) === null || _b === void 0 ? void 0 : _b.includes(entitySet))) {
                let selectorId = change.controlId.split('--')[1].replace(/:3a:3a/g, '::');
                const complexIdMatch = new RegExp('.+DataField.+:::sSmartTableId::.+');
                if (complexIdMatch.exec(selectorId) !== null) {
                    selectorId = selectorId.split('template:::TableColumn:::')[1];
                }
                const idParts = selectorId.split(':::');
                let id, facetID;
                if (idParts.length === 1) {
                    const lastIdParts = idParts[0].split('-');
                    id = lastIdParts[lastIdParts.length - 1];
                    if (idParts[0].indexOf('com.sap.vocabularies.UI.v1.LineItem') >= 0 ||
                        idParts[0].indexOf('UI.LineItem') >= 0 ||
                        idParts[0].indexOf('::Table') >= 0) {
                        facetID = lastIdParts[0]
                            .split('::Table')[0]
                            .split('::responsiveTable')[0]
                            .replace(/::/g, '/@');
                    }
                    else {
                        const idParts = id.split('::');
                        if (idParts.length > 1) {
                            facetID = idParts[0];
                            id = idParts[1];
                        }
                        else if (lastIdParts[0].indexOf('::') > -1) {
                            facetID = lastIdParts[0].split('::')[0];
                        }
                    }
                }
                else if (selectorId.indexOf('sSmartTableId') >= 0) {
                    id = selectorId;
                    for (let index = 0; index < idParts.length; index++) {
                        const element = idParts[index];
                        if (element.startsWith('sSmartTableId')) {
                            facetID = element
                                .split('sSmartTableId::')[1]
                                .split('::Table')[0]
                                .split('/responsiveTable')[0]
                                .replace('::com.sap.vocabularies.UI.v1.LineItem', '/@com.sap.vocabularies.UI.v1.LineItem');
                            break;
                        }
                    }
                }
                else {
                    facetID = idParts[0];
                    id = idParts[1];
                }
                selectorId = selectorId
                    .replace(/:2f/g, '/')
                    .replace(/:40/g, '@')
                    .replace(/:23/g, '#')
                    .replace(/:3a:3a/g, '::')
                    .replace(/\/@com.sap.vocabularies/g, '::com.sap.vocabularies');
                if (result[selectorId] && result[selectorId].propertyId !== change.content.property) {
                    selectorId = selectorId + i;
                    i++;
                }
                result[selectorId] = {
                    controlId: selectorId,
                    propertyId: change.content.property,
                    facetId: facetID,
                    newValue: change.content.newBinding !== undefined ? change.content.newBinding : change.content.newValue,
                    controlType: change.controlType
                };
            }
        }
        catch (error) {
            extensionLogger_1.log(logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('FLEXERROR')
            }, ...error);
        }
    });
    return result;
}
/**
 * Transfers settings from manifest and flexChanges to object page config
 * @param configPart - part of the configuration to be filled
 * @param manifest - manifest.json of the app
 * @param schemaDefinition - current section of the app specific schema
 * @param pageKeys - list of page keys (comprises the one entry describing the given page)
 * @param flexChanges - list of flex changes (pre-processed by prepareFlexChanges)
 * @param sectionId - ID of the given section (optional)
 * @param sectionTitle - title of the section (Facet ID)
 * @param actionId - ID of the given action (optional)
 */
function transferSettingsAndFlexChanges(configPart, manifest, schemaDefinition, pageKeys, flexChanges, jsonSchema, logger, sectionId, sectionTitle, actionId) {
    if (!schemaDefinition) {
        return;
    }
    let deprecatedProperties = [];
    let manifestSection = {};
    if (configPart.getDeprecated) {
        deprecatedProperties = configPart.getDeprecated();
    }
    const unescapedId = sectionId && sectionId.replace(/::@com.sap.vocabularies/g, '/@com.sap.vocabularies');
    for (const propertyKey in schemaDefinition['properties'] || schemaDefinition) {
        const syncRule = common_2.getReflectMetadata(configPart, propertyKey);
        if (syncRule || propertyKey === 'columns') {
            if (propertyKey === 'columns' || (syncRule && syncRule.flex)) {
                if (sectionId) {
                    for (const selector in flexChanges) {
                        if ((flexChanges[selector].propertyId === propertyKey ||
                            (propertyKey === 'columns' &&
                                flexChanges[selector].controlType === common_1.ControlType.TableColumn)) &&
                            flexChanges[selector].facetId &&
                            (flexChanges[selector].facetId === sectionId ||
                                flexChanges[selector].facetId === unescapedId ||
                                flexChanges[selector].facetId === sectionTitle)) {
                            table_1.addFlexForTable(configPart, flexChanges[selector], jsonSchema);
                        }
                    }
                }
                else {
                    for (const selector in flexChanges) {
                        if ((!actionId || selector.endsWith(actionId)) &&
                            ((flexChanges[selector].propertyId === propertyKey && !flexChanges[selector].facetId) ||
                                (flexChanges[selector].propertyId === propertyKey &&
                                    flexChanges[selector].facetId === 'action'))) {
                            configPart[propertyKey] = flexChanges[selector].newValue;
                            break;
                        }
                    }
                }
            }
            else if (syncRule.manifest) {
                const sectionIdInManifest = sectionId
                    ? sectionId.replace(/\/@/g, '::').replace(/@com.sap/g, 'com.sap')
                    : undefined;
                const path = syncRule.manifest.path(pageKeys, {}, sectionIdInManifest);
                manifestSection = manifest_1.getManifestSectionByPathV2(manifest, path);
                const importHandler = syncRule.manifest.import;
                if (importHandler && typeof importHandler === 'function') {
                    const value = importHandler(manifestSection, sectionId);
                    if (value !== undefined) {
                        configPart[propertyKey] = value;
                    }
                }
                else {
                    const manifestKey = syncRule.manifest.key || propertyKey;
                    if (manifestKey in manifestSection) {
                        configPart[propertyKey] = manifestSection[manifestKey];
                    }
                }
                // Check for deprecated properties.
                if (manifestSection && deprecatedProperties) {
                    for (const key in manifestSection) {
                        const deprecated = deprecatedProperties[key];
                        if (deprecated) {
                            extensionLogger_1.log(logger, {
                                severity: "warning" /* Warning */,
                                message: common_2.getTextForDeprecated(key, deprecated),
                                location: {
                                    path: 'webapp/manifest.json/',
                                    range: path.split('/')
                                }
                            });
                            delete deprecatedProperties[key];
                        }
                    }
                }
            }
        }
    }
}
/**
 *  Fills the sections and subsections of the configuration (recursive function)
 * @param sectionProperties - current properties' list (of sections or subsections)
 * @param manifestSettings - object page settings section of the manifest
 * @param configPart - the given part of the object page config
 * @param manifest - manifest.json of the app
 * @param jsonSchema - app specific schema
 * @param pageKeys - list of page keys (comprises the one entry describing the given page)
 * @param flexChanges - list of flex changes (pre-processed by prepareFlexChanges)
 * @param {SapUiAppPageV2} v2Page - v2 page from manifest.
 * @param {ObjectPageConfig} objectPageConfig - page config object.
 * @param {FileData[]} fragments - Array with XML fragments.
 */
function fillSections(sectionProperties, manifestSettings, configPart, manifest, jsonSchema, factory, pageKeys, flexChanges, v2Page, objectPageConfig, fragments, logger) {
    let escapedId, sectionTitle;
    for (const sectionId in sectionProperties) {
        escapedId = sectionId.replace(/\/@/g, '::');
        let schemaSection = sectionProperties[sectionId];
        if (schemaSection['$ref'] &&
            schemaSection['$ref'].startsWith(common_2.DEFINITION_LINK_PREFIX + 'ObjectPageSectionTableV2')) {
            // Section without subsections
            schemaSection = jsonSchema['definitions']['ObjectPageSectionTableV2<' + escapedId + '>'];
            sectionTitle = schemaSection.title ? schemaSection.title.split(v2_1.FacetTitlePrefix)[1] : undefined;
            const manifestKey = escapedId.replace('@com.sap', 'com.sap');
            const manifestSection = manifestSettings && manifestSettings.sections && manifestSettings.sections[manifestKey];
            if (manifestSection || flexChanges) {
                const tableType = manifestSection
                    ? manifestSection.tableSettings
                        ? manifestSection.tableSettings.type
                            ? manifestSection.tableSettings.type
                            : 'ResponsiveTable'
                        : 'ResponsiveTable'
                    : 'ResponsiveTable';
                //Instantiate metadata
                const OPtable = factory.createInstance(common_3.PageType.ObjectPage, 'ObjectPage' + tableType);
                configPart[escapedId] = { table: OPtable };
                let localJsonSchema;
                if (tableType === 'TreeTable' || tableType === 'AnalyticalTable' || tableType === 'GridTable') {
                    localJsonSchema = jsonSchema['definitions']['ObjectPage' + tableType + '<' + escapedId + '>'];
                }
                else {
                    if (jsonSchema['definitions']['ObjectPageResponsiveTableWithMultiSelect<' + escapedId + '>'] &&
                        jsonSchema['definitions']['ObjectPageResponsiveTableWithInlineDelete<' + escapedId + '>']) {
                        localJsonSchema = JSON.parse(JSON.stringify(jsonSchema['definitions']['ObjectPageResponsiveTableWithMultiSelect<' + escapedId + '>']));
                        localJsonSchema['properties'] = Object.assign(Object.assign({}, localJsonSchema['properties']), jsonSchema['definitions']['ObjectPageResponsiveTableWithInlineDelete<' + escapedId + '>']['properties']);
                    }
                }
                transferSettingsAndFlexChanges(configPart[escapedId]['table'], manifest, localJsonSchema, pageKeys, flexChanges, jsonSchema, logger, sectionId, sectionTitle);
                // Custom column ref
                const customColumnSchemaProp = jsonSchema['definitions'][escapedId].properties.custom;
                const customColumnTarget = customColumnSchemaProp
                    ? utils_1.getTargetFromCustomColumnRef(customColumnSchemaProp.$ref)
                    : undefined;
                if (customColumnTarget) {
                    const objectPageSectionData = {
                        key: sectionTitle || escapedId.replace('@', ''),
                        target: customColumnTarget
                    };
                    listReport_1.addFragments(configPart[escapedId], manifest, v2Page, common_3.PageType.ObjectPage, fragments, objectPageSectionData);
                }
            }
        }
        else if (schemaSection['properties'] && schemaSection['properties']['subsections']) {
            // Section with subsections
            configPart[escapedId] = {
                subsections: {}
            };
            schemaSection = jsonSchema['definitions']['ObjectPageSectionTableV2<' + escapedId + '>'];
            sectionTitle = schemaSection.title ? schemaSection.title.split(v2_1.FacetTitlePrefix)[1] : undefined;
            fillSections(schemaSection['properties'], manifestSettings, configPart[escapedId]['subsections'], manifest, jsonSchema, factory, pageKeys, flexChanges, v2Page, objectPageConfig, fragments, logger);
        }
        else if (schemaSection['$ref'] &&
            schemaSection['$ref'] === common_2.DEFINITION_LINK_PREFIX + 'ObjectPageSectionChartV2') {
            // Section without subsections
            schemaSection = jsonSchema['definitions']['ObjectPageSectionChartV2'];
            sectionTitle = schemaSection.title ? schemaSection.title.split(v2_1.FacetTitlePrefix)[1] : undefined;
            const manifestKey = escapedId.replace('@com.sap', 'com.sap');
            const manifestSection = manifestSettings && manifestSettings.sections && manifestSettings.sections[manifestKey];
            const chartConfig = factory.createInstance(common_3.PageType.ObjectPage, 'ObjectPageChart');
            configPart[escapedId] = { chart: chartConfig };
            if (manifestSection || flexChanges) {
                transferSettingsAndFlexChanges(configPart[escapedId]['chart'], manifest, jsonSchema['definitions']['ObjectPageChart'], pageKeys, flexChanges, jsonSchema, logger, sectionId, sectionTitle);
            }
        }
    }
}
/**
 *  Fills the action of the configuration
 * @param actionProperties - current properties' list (of action)
 * @param configPart - the given part of the object page config
 * @param manifest - manifest.json of the app
 * @param jsonSchema - app specific schema
 * @param {MetadataInstanceInterface} factory - factory, for generating the access to reflect-metadata
 * @param pageKeys - list of page keys (comprises the one entry describing the given page)
 * @param flexChanges - list of flex changes (pre-processed by prepareFlexChanges)
 */
function fillActions(actionProperties, configPart, manifest, jsonSchema, factory, pageKeys, flexChanges, logger) {
    let actionId;
    configPart['actions'] = {};
    if (flexChanges.constructor === Object && Object.keys(flexChanges).length !== 0) {
        for (const actionProperty in actionProperties) {
            actionId = actionProperty.replace(/\/@/g, '::');
            configPart['actions'][actionId] = factory.createInstance(common_3.PageType.ObjectPage, 'HeaderAction');
            transferSettingsAndFlexChanges(configPart['actions'][actionId], manifest, jsonSchema['definitions']['HeaderAction'], pageKeys, flexChanges, jsonSchema, logger, undefined, undefined, actionId);
        }
    }
}
/**
 * Fill properties of object page confg based on manifest settings
 * @param objectPageConfig - Object page config (file content)
 * @param manifest - manifest.json of the given app
 * @param jsonSchema - app specific JSON schema
 * @param pageKeys - list of page keys (comprises the one entry describing the given page)
 * @param entitySet - entity set for identifying the given object page
 * @param flexChangesForTransfer - list of flex changes (pre-processed by prepareFlexChanges)
 * @param v2Page - page definition in manifest.json
 * @param {MetadataInstanceInterface} factory - factory, for generating the access to reflect-metadata
 * @param fragments - list of all extension fragment files and their content
 * @param logger - Logger class for logging messages
 */
function fillConfig(objectPageConfig, manifest, jsonSchema, pageKeys, entitySet, flexChangesForTransfer, v2Page, factory, fragments, logger) {
    const manifestSettings = v2Page.component.settings;
    // Transfer page information
    transferSettingsAndFlexChanges(objectPageConfig, manifest, jsonSchema['properties'], pageKeys, flexChangesForTransfer, jsonSchema, logger);
    // Transfer header information
    objectPageConfig.header = factory.createInstance(common_3.PageType.ObjectPage, 'ObjectPageHeader');
    transferSettingsAndFlexChanges(objectPageConfig.header, manifest, jsonSchema['definitions']['ObjectPageHeader']
        ? jsonSchema['definitions']['ObjectPageHeader']
        : jsonSchema['definitions']['ObjectPageHeader<GenericActions>'], pageKeys, flexChangesForTransfer, jsonSchema, logger);
    const headerAction = jsonSchema['definitions']['HeaderActions'];
    if (headerAction) {
        fillActions(headerAction.properties, objectPageConfig.header, manifest, jsonSchema, factory, pageKeys, flexChangesForTransfer, logger);
    }
    // Transfer Layout information
    objectPageConfig.layout = factory.createInstance(common_3.PageType.ObjectPage, 'ObjectPageLayout');
    transferSettingsAndFlexChanges(objectPageConfig.layout, manifest, jsonSchema['definitions']['ObjectPageLayout'], pageKeys, flexChangesForTransfer, jsonSchema, logger);
    if (Object.keys(objectPageConfig.layout).length === 0) {
        delete objectPageConfig.layout;
    }
    // Fill sections and subsections
    objectPageConfig.sections = {};
    const sections = jsonSchema['definitions']['Sections'];
    if (sections) {
        fillSections(sections.properties, manifestSettings, objectPageConfig.sections, manifest, jsonSchema, factory, pageKeys, flexChangesForTransfer, v2Page, objectPageConfig, fragments, logger);
    }
    // Find custom sections
    const customSections = utils_1.findCustomSectionExtensions(manifest, entitySet);
    if (Object.keys(customSections).length > 0) {
        objectPageConfig.sections.custom = [];
        for (const sectionId in customSections) {
            const customSection = 'fragmentName' in customSections[sectionId]
                ? factory.createInstance(common_3.PageType.ObjectPage, 'ObjectPageCustomSectionFragment')
                : factory.createInstance(common_3.PageType.ObjectPage, 'ObjectPageCustomSectionView');
            transferSettingsAndFlexChanges(customSection, manifest, jsonSchema['definitions']['fragmentName' in customSections[sectionId]
                ? 'ObjectPageCustomSectionFragment'
                : 'ObjectPageCustomSectionView'], pageKeys, flexChangesForTransfer, jsonSchema, logger, sectionId);
            objectPageConfig.sections.custom.push(customSection);
        }
    }
}
/**
 * Creates the configuration (file content) for a V2 object page
 * @param {object} manifest  - manifest of the app
 * @param {string[]} flex - list of flex changes (from UI adaptatin)
 * @param {object} jsonSchema - app specific JSON schema
 * @param {string} entitySet - current entity set, identifying the given page
 * @param {FileData[]} fragments - list of all extension fragment files and their content
 * @param {ExtensionLogger} logger - Logger class for logging messages
 *
 * @returns {ObjectPageConfig} - the object page configuration (JSON)
 */
function createObjectPageConfig(manifest, flex, jsonSchema, entitySet, fragments, logger) {
    // Initialize i18next
    i18n_1.initI18n();
    if (!manifest[common_3.ManifestSection.generic]) {
        extensionLogger_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOFE'),
            location: {
                path: v2_1.MANIFESTPATH,
                range: [common_3.ManifestSection.generic]
            }
        });
        return;
    }
    const pageKeys = [];
    const v2Pages = manifest[common_3.ManifestSection.generic].pages;
    if (!v2Pages) {
        extensionLogger_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOPAGES', { appId: manifest['sap.app']['id'] }),
            location: {
                path: v2_1.MANIFESTPATH,
                range: [common_3.ManifestSection.generic]
            }
        });
        return;
    }
    const v2Page = utils_1.findObjectPage(v2Pages, entitySet, pageKeys);
    if (!v2Page) {
        extensionLogger_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOENTITYSET', { entitySet }),
            location: {
                path: v2_1.MANIFESTPATH,
                range: [common_3.ManifestSection.generic]
            }
        });
        return;
    }
    const flexChangesForTransfer = prepareFlexChanges(flex, entitySet);
    const factory = new factory_1.MetadataInstanceFactoryV2();
    //Instantiate Page
    const config = factory.createPageInstance(common_3.PageType.ObjectPage);
    //Fill config.json with manifest settings and flex changes
    fillConfig(config, manifest, jsonSchema, pageKeys, entitySet, flexChangesForTransfer, v2Page, factory, fragments, logger);
    return config;
}
exports.createObjectPageConfig = createObjectPageConfig;
//# sourceMappingURL=objectPage.js.map