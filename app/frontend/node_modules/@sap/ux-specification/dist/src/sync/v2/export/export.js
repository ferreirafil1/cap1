"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const factory_1 = require("./factory");
const ajv_1 = __importDefault(require("ajv"));
const lodash_unset_1 = __importDefault(require("lodash.unset"));
const deepmerge_1 = __importDefault(require("deepmerge"));
const controls_1 = require("./controls");
const common_1 = require("../../common");
const v2_1 = require("../../../v2");
const application_1 = require("../application");
const manifest_1 = require("./manifest");
const utils_1 = require("../import/utils");
const i18next_1 = __importDefault(require("i18next"));
/**
 * Returns a fresh export results object with default values
 */
const getDefaultExportResult = (fragmentFiles) => ({
    flexChanges: [],
    manifest: {
        'sap.ui.generic.app': { pages: {} }
    },
    fragments: fragmentFiles ? fragmentFiles : []
});
/**
 * Create missing card from the manifest
 * @param key - card name
 * @param ovp - OVP section of manifest, to be updated
 */
function createCard(key, ovp) {
    if (!ovp.cards) {
        ovp.cards = {};
    }
    if (!(key in ovp.cards)) {
        ovp.cards[key] = {};
    }
}
/**
 * Recursive function that searches for next avaialble id by increasing number by 1.
 * @param {boolean} sectionIds All ids in use.
 * @param {string} candidateId Candidate id to check if it is available.
 * @return {string} Id string.
 */
function findAvailableId(sectionIds, candidateId) {
    if (sectionIds.includes(candidateId)) {
        const idParts = candidateId.split('|');
        if (idParts.length === 3) {
            idParts.push('1');
        }
        else {
            idParts[3] = (parseInt(idParts[3]) + 1).toString();
        }
        return findAvailableId(sectionIds, idParts.join('|'));
    }
    return candidateId;
}
/**
 * Private recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param configObject - current object to traverse
 * @param manifest - app descriptor (manifest.json)
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param jsonSchema - application specific schema
 * @param targetDefinition - the current entry point or definition in the app schema
 * @param pathHierarchy -  elements of the path indicating the hierarchical level
 */
function transferManifestEntriesOVP(configObject, manifest, exportResults, jsonSchema, targetDefinition, factory, pathHierarchy) {
    if (targetDefinition) {
        if (targetDefinition['properties']) {
            processProperties(configObject, manifest, exportResults, jsonSchema, targetDefinition['properties'], factory, pathHierarchy);
        }
        else if (targetDefinition['additionalProperties']) {
            processProperties(configObject, manifest, exportResults, jsonSchema, targetDefinition['additionalProperties'], factory, pathHierarchy);
        }
    }
}
/**
 * Assign sync rules to {currentObject}
 *
 * @param {string} structureName - name of the complex structure in schema
 * @param {object} currentObject - the given part of the configuration
 * @param {string} defaultTypeName - name of the default type that shall be taken if no class is registered for structureName
 */
function assignReflectMetadataRules(factory, structureName, currentObject, defaultTypeName) {
    return factory.createInstance(v2_1.PageType.OverviewPage, defaultTypeName, currentObject, structureName);
}
exports.assignReflectMetadataRules = assignReflectMetadataRules;
/**
 * Recursive function that transfers the content of a list of properties of a configuration to the overall exportResults
 * @param configObject - the given part of the configuration
 * @param manifest - manifest.json of the app
 * @param exportResults - overall result list, to be updated
 * @param jsonSchema - app-specific JSOn schema
 * @param propertyList - current property list of the config (properties or additional properties)
 * @param pathHierarchy -  elements of the path indicating the hierarchical level
 */
function processProperties(configObject, manifest, exportResults, jsonSchema, propertyList, factory, pathHierarchy) {
    let currentObject;
    let isAnyOfObject = false;
    let isObjectProperty = false;
    const exceptionList = ['colorPalette', 'tabs'];
    for (const key in propertyList) {
        currentObject = configObject[key];
        let syncRule = common_1.getReflectMetadata(configObject, key);
        if (pathHierarchy[pathHierarchy.length - 1] === 'anyOfObject') {
            isAnyOfObject = true;
            pathHierarchy.pop();
        }
        if (isAnyOfObject) {
            currentObject = configObject[pathHierarchy[pathHierarchy.length - 1]][key];
            syncRule = common_1.getReflectMetadata(configObject, pathHierarchy[pathHierarchy.length - 1]);
        }
        if (pathHierarchy[pathHierarchy.length - 1] === 'objectProperties') {
            isObjectProperty = true;
            pathHierarchy.pop();
        }
        if (isObjectProperty) {
            currentObject = configObject[pathHierarchy[pathHierarchy.length - 1]][key];
            syncRule = common_1.getReflectMetadata(configObject, pathHierarchy[pathHierarchy.length - 1]);
        }
        if (pathHierarchy[pathHierarchy.length - 1] === 'anyOf') {
            pathHierarchy.pop();
            for (const key in propertyList['anyOf']) {
                if (propertyList['anyOf'][key].$ref) {
                    const definitionArray = propertyList['anyOf'][key].$ref.split('#/definitions/');
                    const nextTargetDefinition = jsonSchema['definitions'][definitionArray[definitionArray.length - 1]];
                    const cardSettingsType = pathHierarchy[1];
                    currentObject = configObject[cardSettingsType];
                    currentObject = assignReflectMetadataRules(factory, cardSettingsType, currentObject, 'CustomCard');
                    transferManifestEntriesOVP(currentObject, manifest, exportResults, jsonSchema, nextTargetDefinition, factory, [...pathHierarchy]);
                }
                else if (typeof propertyList['anyOf'][key] === 'object') {
                    processProperties(configObject, manifest, exportResults, jsonSchema, propertyList['anyOf'][key].properties, factory, [...pathHierarchy, 'anyOfObject']);
                }
            }
        }
        if (syncRule) {
            if (syncRule.manifest) {
                const path = syncRule.manifest.path([...pathHierarchy, key]);
                const manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, path);
                if (key in v2_1.CardSettingsType || key === 'settings') {
                    manifestSection['settings'] = deepmerge_1.default(manifestSection['settings'] || {}, currentObject || {}, {
                        arrayMerge: common_1.arrayCombineMerge
                    });
                }
                else if (currentObject !== undefined) {
                    const exportHandler = syncRule.manifest.export;
                    if (exportHandler !== false) {
                        if (exportHandler && typeof exportHandler === 'function') {
                            exportHandler(manifestSection, configObject, key);
                        }
                        else if (typeof currentObject === 'object' && !exceptionList.includes(key)) {
                            // colorPalette is an exception as it can contain anything as per our schema, so just replace the object
                            manifestSection[key] = deepmerge_1.default(manifestSection[key] || {}, currentObject || {}, {
                                arrayMerge: common_1.arrayCombineMerge
                            });
                        }
                        else {
                            manifestSection[key] = currentObject;
                        }
                    }
                }
                else if (manifestSection[key] !== undefined) {
                    delete manifestSection[key];
                }
            }
        }
        if (currentObject && typeof currentObject === 'object' && propertyList[key]) {
            if (key === 'cards') {
                //inserts and updates:
                Object.keys(currentObject).forEach((cardKey) => {
                    const cardType = currentObject[cardKey].template;
                    //Determine target defintion
                    let targetDefinition;
                    if (!Object.values(v2_1.CardTemplateType).includes(cardType)) {
                        targetDefinition = ['CustomCard'];
                    }
                    else {
                        targetDefinition = Object.keys(jsonSchema['definitions']).filter((definition) => {
                            var _a, _b, _c;
                            return ((_c = (_b = (_a = jsonSchema['definitions'][definition].properties) === null || _a === void 0 ? void 0 : _a.template) === null || _b === void 0 ? void 0 : _b.enum) === null || _c === void 0 ? void 0 : _c.indexOf(currentObject[cardKey].template)) > -1;
                        });
                    }
                    //Get metadata
                    currentObject[cardKey] = assignReflectMetadataRules(factory, targetDefinition[0], currentObject[cardKey], 'CustomCard');
                    createCard(cardKey, exportResults['manifest'][v2_1.ManifestSection.ovp]);
                    transferManifestEntriesOVP(currentObject[cardKey], manifest, exportResults, jsonSchema, jsonSchema['definitions'][targetDefinition[0]], factory, [cardKey]);
                });
                //check for deletions:
                Object.keys(manifest[v2_1.ManifestSection.ovp].cards).forEach((manifestCard) => {
                    if (!currentObject[manifestCard]) {
                        delete exportResults.manifest[v2_1.ManifestSection.ovp].cards[manifestCard];
                    }
                });
            }
            else if (propertyList[key].$ref) {
                const definitionArray = propertyList[key].$ref.split(common_1.DEFINITION_LINK_PREFIX);
                const nextTargetDefinition = jsonSchema['definitions'][definitionArray[definitionArray.length - 1]];
                currentObject = assignReflectMetadataRules(factory, key, currentObject, key === 'settings' ? 'CustomCard' : '');
                transferManifestEntriesOVP(currentObject, manifest, exportResults, jsonSchema, nextTargetDefinition, factory, [...pathHierarchy, key]);
            }
            else if (propertyList[key].anyOf) {
                processProperties(configObject, manifest, exportResults, jsonSchema, propertyList[key], factory, [
                    ...pathHierarchy,
                    key,
                    'anyOf'
                ]);
            }
            else if (propertyList[key]['properties'] !== undefined) {
                processProperties(configObject, manifest, exportResults, jsonSchema, propertyList[key].properties, factory, [...pathHierarchy, key, 'objectProperties']);
            }
        }
    }
}
/**
 * Evaluates an export rule for a property or object, transfers to flex change or manifest setting
 * @param syncRule - export rule from the object classes decorator
 * @param configObject - current (sub)object of the configuration file
 * @param breadcrumbs - list of breadcrumbs, i.e. ID parts for building the stable ID
 * @param baseId - selector id of the current page
 * @param ids - list of parent & child ids
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @param key - key of the given property
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param fullManifest - old or existing manifest
 * @param pageKeys - array of keys to identify component in manifest
 * @param manifestSection - current manifest section
 */
function evaluateExportRule(syncRule, configObject, breadcrumbs, baseId, ids, title, key, exportResults, fullManifest, pageKeys, manifestSection, ui5Version) {
    function getManifestPath() {
        let path;
        if (breadcrumbs[0] === 'sections') {
            if (breadcrumbs[1] === 'custom') {
                path = syncRule.manifest.path(pageKeys, {}, breadcrumbs[2]);
            }
            else {
                path = syncRule.manifest.path(pageKeys, {}, breadcrumbs[1]);
                path = path.replace('/@', '::').replace(/::@com.sap.vocabularies/g, '::com.sap.vocabularies');
            }
        }
        else if (breadcrumbs[0] === 'table') {
            if (breadcrumbs[1] === 'columns' && breadcrumbs[2] === 'custom') {
                path = syncRule.manifest.path(pageKeys, fullManifest, configObject['tabKey']);
            }
            else {
                path = syncRule.manifest.path(pageKeys, {}, breadcrumbs[1]);
            }
        }
        else if (breadcrumbs[0] === 'keyPerformanceIndicators') {
            path = syncRule.manifest.path(pageKeys, fullManifest, title);
        }
        else {
            path = syncRule.manifest.path(pageKeys);
        }
        return path;
    }
    let localBreadcrumbs;
    //eliminate subsections' hierarchy
    let index = breadcrumbs.indexOf('subsections');
    while (index > -1) {
        breadcrumbs.splice(index - 1, 2);
        index = breadcrumbs.indexOf('subsections');
    }
    if (syncRule.flex) {
        if (breadcrumbs.length === 0) {
            //only added on top = page level, do not forward
            localBreadcrumbs = ['page'];
        }
        else {
            localBreadcrumbs = breadcrumbs;
        }
        const flexChange = common_1.createFlexChange(configObject, localBreadcrumbs, syncRule, ui5Version, baseId, ids, title, key);
        let flexChangeExists;
        const completeFlexChange = syncRule.flex.createFlexChange(flexChange, fullManifest);
        exportResults.flexChanges.find((change) => {
            let oldChange = JSON.parse(change);
            oldChange = {
                content: oldChange['content'],
                selector: oldChange['selector']
            };
            let newChange = JSON.parse(completeFlexChange);
            newChange = {
                content: newChange['content'],
                selector: newChange['selector']
            };
            if (JSON.stringify(oldChange) === JSON.stringify(newChange)) {
                flexChangeExists = true;
            }
            return flexChangeExists;
        });
        if (!flexChangeExists) {
            exportResults.flexChanges.push(completeFlexChange);
        }
    }
    else if (syncRule.manifest) {
        const path = getManifestPath();
        manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, path);
        const manifestKey = syncRule.manifest.key || key;
        if (configObject[key] !== undefined) {
            if (!syncRule.hasDistinctDefinition) {
                const exportHandler = syncRule.manifest.export;
                if (exportHandler !== false) {
                    if (exportHandler && typeof exportHandler === 'function') {
                        exportHandler(manifestSection, configObject, key);
                    }
                    else {
                        manifestSection[manifestKey] = configObject[key];
                    }
                }
            }
            else if (manifestSection[manifestKey] === undefined) {
                manifestSection[manifestKey] = {};
            }
        }
        else {
            if (Object.prototype.hasOwnProperty.call(manifestSection, manifestKey)) {
                delete manifestSection[manifestKey];
            }
        }
        common_1.deleteEmptyStructure(exportResults.manifest, path);
    }
}
/**
 * Instantiates the export classes for the object page section
 * @param objectPageConfig - the given object page configuration
 * @param objectPage - the overall object page export class where the sections shall be included
 */
function getExportClassesForSections(objectPageConfig, objectPage, v2Page, factory) {
    var _a;
    /**
     * Instantiates the export classes for a single object page section
     * @param section - Export class as an object, to be updated
     * @param sectionId - Current section ID
     */
    function getClassesForSingleSection(section, sectionId, sectionInManifest, factory) {
        if (section && sectionId === 'custom' && Array.isArray(section)) {
            // Custom sections
            for (const index in section) {
                if (section[index].className === v2_1.SAPUI5_FRAGMENT_CLASS) {
                    section[index] = factory.createInstance(v2_1.PageType.ObjectPage, 'ObjectPageCustomSectionFragment', section[index]);
                }
                else {
                    section[index] = factory.createInstance(v2_1.PageType.ObjectPage, 'ObjectPageCustomSectionView', section[index]);
                }
            }
        }
    }
    /**
     * Recursive sub-function for handling subsections
     * @param section - Object page section in config
     */
    function getSubsectionClasses(section, factory) {
        var _a;
        if (section['subsections']) {
            let subSection, sectionInManifest;
            for (const subSectionId in section['subsections']) {
                subSection = section['subsections'][subSectionId];
                sectionInManifest =
                    ((_a = v2Page.component.settings) === null || _a === void 0 ? void 0 : _a.sections) && v2Page.component.settings.sections[subSectionId];
                getClassesForSingleSection(subSection, subSectionId, sectionInManifest, factory);
                getSubsectionClasses(subSection, factory);
            }
        }
    }
    // Main function
    let section, sectionInManifest;
    for (const sectionId in objectPageConfig.sections) {
        section = objectPage.sections[sectionId];
        sectionInManifest = ((_a = v2Page.component.settings) === null || _a === void 0 ? void 0 : _a.sections) && v2Page.component.settings.sections[sectionId];
        getClassesForSingleSection(section, sectionId, sectionInManifest, factory);
        getSubsectionClasses(section, factory);
    }
}
/**
 * Transfers column extensions to manifest and fragment files
 * @param {TableCustomColumns} config - config part comprising the table custom columns
 * @param {ExportResults} exportResults - object with all collected manifest entries and flex changes
 * @param {string} appId - id of the Fiori elements app, which is usually namespace.appid
 * @param {object} schemaDefinition - Column schema definition
 * @param {SapUiAppPageV2} page - Page object from manifest.
 * @param {ObjectPageSectionData} [objectPageSectionData] - Object Page section's data containing target and key options.
 */
function transferColumnExtensions(config, exportResults, appId, schemaDefinition, logger, page, objectPageSectionData) {
    const sectionKey = objectPageSectionData ? objectPageSectionData.key : undefined;
    const sectionTarget = objectPageSectionData ? objectPageSectionData.target : undefined;
    const entitySet = sectionTarget || page.entitySet;
    for (const extensionType in v2_1.TableColumnExtensionTypeV2) {
        const { path, viewTemplateType } = controls_1.getCustomColumnPath(page, entitySet, sectionKey, extensionType);
        if (!path) {
            continue;
        }
        const folderPath = path.substr(0, path.lastIndexOf('/'));
        const manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, folderPath);
        const extensionPattern = path.substr(path.lastIndexOf('/') + 1);
        for (const key in manifestSection) {
            if (key.startsWith(extensionPattern)) {
                const [keyExtensionType, keyEntitySet, keyTab] = key.split('|');
                if (keyEntitySet === entitySet) {
                    //relevant extension. still present in config?
                    const existingConfigEntries = config === null || config === void 0 ? void 0 : config.filter((column) => (column.tabKey === keyTab ||
                        (keyTab === undefined && column.tabKey === '') ||
                        (keyTab && sectionKey === keyTab)) &&
                        column.extensionType === extensionType);
                    if (!existingConfigEntries || existingConfigEntries.length === 0) {
                        controls_1.deleteColumnFromFragment(manifestSection, key, appId, exportResults.fragments);
                        // delete from manifest
                        delete manifestSection[key];
                        // delete cells entry
                        if (key.startsWith(common_1.ViewTemplateType.ResponsiveTableColumnsExtension)) {
                            const cellsPattern = key.replace(common_1.ViewTemplateType.ResponsiveTableColumnsExtension, common_1.ViewTemplateType.ResponsiveTableCellsExtension);
                            controls_1.deleteColumnFromFragment(manifestSection, cellsPattern, appId, exportResults.fragments);
                            // delete from manifest
                            delete manifestSection[cellsPattern];
                        }
                    }
                }
            }
        }
    }
    //cluster existing custom columns by manifest path (or tab key)
    const cluster = {};
    if (config) {
        for (let index = 0; index < config.length; index++) {
            const customColumn = config[index];
            //verify that mandatory parameters are filled
            if (!customColumn['className'] ||
                !customColumn['fragmentName'] ||
                !customColumn['columnKey'] ||
                !customColumn['extensionType']) {
                continue;
            }
            //check fragment name
            if (schemaDefinition['properties']['fragmentName']['pattern']) {
                const namePattern = new RegExp(schemaDefinition['properties']['fragmentName']['pattern']);
                if (namePattern.test(customColumn['fragmentName']) === false) {
                    continue;
                }
            }
            const { path, viewTemplateType } = controls_1.getCustomColumnPath(page, entitySet, customColumn.tabKey || sectionKey, customColumn['extensionType']);
            if (!cluster[path]) {
                cluster[path] = {
                    viewTemplateType: viewTemplateType,
                    columns: []
                };
            }
            cluster[path].columns.push(customColumn);
        }
        //Export to fragment
        for (const path in cluster) {
            controls_1.exportToFragment(exportResults, path, cluster[path].columns, appId, cluster[path].viewTemplateType, logger);
        }
    }
}
/**
 * Recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param configSections - sections from configuration object
 * @param pageKey  - page key
 * @param fullManifest - the complete manifest.json file content
 * @param parentIds - array of collected parent ids
 * @param manifest - app descriptor (manifest.json)
 * @param breadcrumbs - array of properties that we are currently processing. Required for instance for table column name
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param baseId - selector id of the current page
 * @param pageKeys - array of keys to identify component in manifest
 * @param jsonSchema - application specific schema
 * @param targetDefinition - the current entry point or definition in the app schema
 * @param entityAnnotations - list of annotations of the entity type that the page is referring to
 */
function transferManifestExtensions(pageType, configSections, pageKey, fullManifest, parentIds, manifest, breadcrumbs, exportResults, appId, baseId, pageKeys, jsonSchema, targetDefinition, ui5Version, factory) {
    const sectionIds = [];
    const entity = pageKey.split('|')[1];
    if (!configSections) {
        return;
    }
    for (const section of configSections) {
        const id = findAvailableId(sectionIds, [section.relativePosition, entity, section.relatedFacet].join('|'));
        sectionIds.push(id);
    }
    for (const index in sectionIds) {
        const definition = targetDefinition['anyOf'].find((element) => element.$ref.includes(configSections[index].constructor.name));
        const definitionArray = definition.$ref.split(common_1.DEFINITION_LINK_PREFIX);
        const nextTargetDefinition = jsonSchema['definitions'][definitionArray[definitionArray.length - 1]];
        transferManifestEntriesAndFlexChange(pageType, fullManifest, configSections[index], parentIds, manifest, [...breadcrumbs, sectionIds[index]], exportResults, appId, baseId, pageKeys, jsonSchema, nextTargetDefinition, ui5Version, factory);
    }
    // Delete removed manifest entries
    const manifestSections = manifest_1.getManifestSectionByPathV2(exportResults.manifest, application_1.getViewExtensionsPath());
    for (const key in manifestSections) {
        if (utils_1.isAssociatedCustomSection(key, entity) && !sectionIds.includes(key)) {
            delete manifestSections[key];
        }
    }
}
/**
 * Method returns converted section id by resolving passed section id and title from schema.
 * @param {string[]} breadcrumbs Array of properties that we are currently processing. Required for instance for table column name.
 * @param {string} title Title from JSON schema, comprising the facet ID
 * @returns {string | undefined} Resolved section id.
 */
function getSectionId(breadcrumbs, title) {
    let sectionId = undefined;
    for (let i = breadcrumbs.length - 1; i >= 0; i--) {
        if (breadcrumbs[i] === 'table') {
            sectionId = breadcrumbs[i - 1];
            break;
        }
    }
    return common_1.convertSectionId(sectionId, title);
}
/**
 * Recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param configObject - current (sub)object of the configuration file
 * @param parentIds - array of collected parent ids
 * @param manifest - app descriptor (manifest.json)
 * @param breadcrumbs - array of properties that we are currently processing. Required for instance for table column name
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param baseId - selector id of the current page
 * @param pageKeys - array of keys to identify component in manifest
 * @param jsonSchema - application specific schema
 * @param schemaDefinition - the current entry point or definition in the app schema
 * @param title - title from the app schema (comprising for instance the facet ID)
 */
function transferManifestEntriesAndFlexChange(pageType, fullManifest, configObject, parentIds, manifest, breadcrumbs, exportResults, appId, baseId, pageKeys, jsonSchema, schemaDefinition, ui5Version, factory, title, logger) {
    let manifestSection, currentConfigObject;
    if (schemaDefinition && schemaDefinition['properties']) {
        for (const key in schemaDefinition['properties']) {
            currentConfigObject = configObject && configObject[key];
            const childId = configObject && common_1.getChildId(configObject, key);
            const ids = childId ? [...parentIds, childId] : parentIds;
            const syncRule = common_1.getReflectMetadata(configObject, key);
            if (syncRule) {
                evaluateExportRule(syncRule, configObject, breadcrumbs, baseId, ids, title, key, exportResults, fullManifest, pageKeys, manifestSection, ui5Version);
            }
            const propertyDefinition = schemaDefinition['properties'][key];
            if (currentConfigObject && propertyDefinition.additionalProperties) {
                //index table
                Object.keys(currentConfigObject).forEach((newKey) => {
                    const nextDefinition = common_1.getNextTargetDefinition(jsonSchema, title, currentConfigObject[newKey], propertyDefinition.additionalProperties, key, factory, pageType);
                    transferManifestEntriesAndFlexChange(pageType, fullManifest, nextDefinition.configObject, ids, manifest, [...breadcrumbs, key], exportResults, appId, baseId, pageKeys, jsonSchema, nextDefinition.targetDefinition, ui5Version, factory, newKey, logger);
                });
            }
            if ((currentConfigObject === undefined || typeof currentConfigObject === 'object') && propertyDefinition) {
                if (propertyDefinition.type === 'array' &&
                    (breadcrumbs[0] === 'sections' || breadcrumbs[0] === 'subsections') &&
                    key === 'custom') {
                    transferManifestExtensions(pageType, configObject[key], pageKeys[pageKeys.length - 1], fullManifest, ids, manifest, [...breadcrumbs, key], exportResults, appId, baseId, pageKeys, jsonSchema, propertyDefinition.items, ui5Version, factory);
                    continue;
                }
                let nextDefinition = common_1.getNextTargetDefinition(jsonSchema, title, currentConfigObject, propertyDefinition, key, factory, pageType);
                if (nextDefinition && key === 'custom') {
                    let objectPageSectionData;
                    const target = utils_1.getTargetFromCustomColumnRef(propertyDefinition.$ref);
                    if (target) {
                        objectPageSectionData = {
                            target,
                            key: getSectionId(breadcrumbs, title)
                        };
                    }
                    transferColumnExtensions(configObject === null || configObject === void 0 ? void 0 : configObject.custom, exportResults, appId, nextDefinition.targetDefinition, logger, manifest, objectPageSectionData);
                    continue;
                }
                else if (nextDefinition) {
                    transferManifestEntriesAndFlexChange(pageType, fullManifest, nextDefinition.configObject, ids, manifest, [...breadcrumbs, key], exportResults, appId, baseId, pageKeys, jsonSchema, nextDefinition.targetDefinition, ui5Version, factory, nextDefinition.title, logger);
                }
                else if (propertyDefinition['anyOf']) {
                    propertyDefinition['anyOf'].forEach((element) => {
                        nextDefinition = common_1.getNextTargetDefinition(jsonSchema, title, currentConfigObject, element, key, factory, pageType);
                        if (nextDefinition) {
                            transferManifestEntriesAndFlexChange(pageType, fullManifest, nextDefinition.configObject, ids, manifest, [...breadcrumbs, key], exportResults, appId, baseId, pageKeys, jsonSchema, nextDefinition.targetDefinition, ui5Version, factory, nextDefinition.title, logger);
                        }
                    });
                }
            }
            else if (propertyDefinition &&
                propertyDefinition.$ref === common_1.DEFINITION_LINK_PREFIX + 'TableCustomColumns') {
                //empty config ==> delete all given extensions
                transferColumnExtensions([], exportResults, appId, jsonSchema['definitions']['TableCustomColumn'], logger, manifest);
                continue;
            }
        }
    }
}
/**
 * Run through the given ListReport config and return respective manifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param page - page definition and configuration file content
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @param ui5Version - SAP UI5 version
 * @param fragments - list of all extension fragment files and their content
 * @param logger - Logger class for logging messages
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
function exportListReportPage(appId, page, manifest, jsonSchema, ui5Version, fragments, logger) {
    const listReportConfig = page.config;
    const entitySet = page.entitySet;
    const exportResults = getDefaultExportResult(fragments);
    const factory = new factory_1.MetadataInstanceFactoryV2();
    const listReport = factory.createPageInstance(v2_1.PageType.ListReport, listReportConfig);
    const pageLayoutInformation = common_1.getPageLayoutInformation(listReport);
    const baseId = `${appId}::${pageLayoutInformation.id}::${entitySet}--`;
    const pageKeys = [];
    const v2Page = utils_1.findListReportPage(manifest[v2_1.ManifestSection.generic].pages, pageKeys);
    if (!v2Page) {
        v2_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOLR'),
            location: {
                path: v2_1.MANIFESTPATH,
                range: [v2_1.ManifestSection.generic]
            }
        });
        return;
    }
    if (!v2Page.component.settings) {
        v2Page.component.settings = {};
    }
    exportResults.manifest = JSON.parse(JSON.stringify(manifest));
    if (listReportConfig && Object.keys(listReportConfig).length !== 0) {
        transferManifestEntriesAndFlexChange(v2_1.PageType.ListReport, exportResults.manifest, listReport, [], v2Page, [], exportResults, appId, baseId, pageKeys, jsonSchema, jsonSchema, //starting point for target definition
        ui5Version, factory, undefined, //title
        logger);
    }
    return exportResults;
}
/**
 * Run through the given AnalyticalListPage config and return respective manifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param page - page definition and configuration file content
 * @param entitySet - name of the entity set
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @param ui5Version - SAP UI5 version
 * @param fragments - list of all extension fragment files and their content
 * @param logger - Logger class for logging messages
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
function exportAnalyticalListPage(appId, page, manifest, jsonSchema, ui5Version, fragments, logger) {
    const analyticalListPageConfig = page.config;
    const entitySet = page.entitySet;
    const exportResults = getDefaultExportResult(fragments);
    exportResults.flexChanges = [];
    exportResults.manifest = JSON.parse(JSON.stringify(manifest));
    const factory = new factory_1.MetadataInstanceFactoryV2();
    //Instantiate Page
    const analyticalListPage = factory.createPageInstance(v2_1.PageType.AnalyticalListPage, analyticalListPageConfig);
    //Instantiate base ID
    const pageLayoutInformation = common_1.getPageLayoutInformation(analyticalListPage);
    const baseId = `${appId}::${pageLayoutInformation.id}::${entitySet}--`;
    const pageKeys = [];
    const v2Page = utils_1.findAnalyticalListPage(manifest[v2_1.ManifestSection.generic].pages, pageKeys);
    if (!v2Page) {
        v2_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOALP'),
            location: {
                path: v2_1.MANIFESTPATH,
                range: [v2_1.ManifestSection.generic]
            }
        });
        return;
    }
    if (!v2Page.component.settings) {
        v2Page.component.settings = {};
    }
    exportResults.manifest = JSON.parse(JSON.stringify(manifest));
    if (analyticalListPageConfig && Object.keys(analyticalListPageConfig).length !== 0) {
        transferManifestEntriesAndFlexChange(v2_1.PageType.AnalyticalListPage, exportResults.manifest, analyticalListPage, [], v2Page, [], exportResults, appId, baseId, pageKeys, jsonSchema, jsonSchema, //starting point for target definition
        ui5Version, factory, undefined, logger);
    }
    return exportResults;
}
/**
 * Run through the given ObjectPage config and return respective manifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param page - page definition and configuration file content
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @param ui5Version - SAP UI5 version
 * @param fragments - list of all extension fragment files and their content
 * @param logger - Logger class for logging messages
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
function exportObjectPage(appId, page, manifest, jsonSchema, ui5Version, fragments, logger) {
    const objectPageConfig = page.config;
    const entitySet = page.entitySet;
    const exportResults = getDefaultExportResult(fragments);
    const factory = new factory_1.MetadataInstanceFactoryV2();
    const objectPage = factory.createPageInstance(v2_1.PageType.ObjectPage, objectPageConfig);
    if (objectPageConfig) {
        const pageLayoutInformation = common_1.getPageLayoutInformation(objectPage);
        const baseId = `${appId}::${pageLayoutInformation.id}::${entitySet}--`;
        exportResults.manifest = JSON.parse(JSON.stringify(manifest));
        const pageKeys = [];
        const v2Page = utils_1.findObjectPage(manifest[v2_1.ManifestSection.generic].pages, entitySet, pageKeys);
        if (!v2Page) {
            return exportResults;
        }
        if (objectPageConfig && objectPageConfig.sections) {
            getExportClassesForSections(objectPageConfig, objectPage, v2Page, factory);
        }
        if (objectPageConfig && Object.keys(objectPageConfig).length !== 0) {
            transferManifestEntriesAndFlexChange(v2_1.PageType.ObjectPage, exportResults.manifest, objectPage, [], v2Page, [], exportResults, appId, baseId, pageKeys, jsonSchema, jsonSchema, //starting point for target definition
            ui5Version, factory, undefined, logger);
        }
        return exportResults;
    }
    else {
        exportResults.manifest = JSON.parse(JSON.stringify(manifest));
        return exportResults;
    }
}
/**
 * Run through the given ObjectPage config and return respective manifest entry and flex changes
 * @param overviewPageConfig - content of the src/OverviewPage_<entity_set>.json file
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
const exportOverviewPage = (overviewPageConfig, manifest, jsonSchema) => {
    const exportResults = getDefaultExportResult();
    const factory = new factory_1.MetadataInstanceFactoryV2();
    const overviewPage = factory.createPageInstance(v2_1.PageType.OverviewPage, overviewPageConfig);
    const ajv = new ajv_1.default({ allErrors: true });
    const validate = ajv.compile(jsonSchema);
    if (!validate(overviewPage)) {
        for (const err of validate.errors) {
            const additionalProperty = err.params['additionalProperty'];
            if (err.keyword === 'additionalProperties' &&
                !Object.values(v2_1.CardSettingsType).includes(err.params['additionalProperty']) &&
                additionalProperty !== 'settings') {
                lodash_unset_1.default(overviewPage, `${err.dataPath.slice(1)}.${additionalProperty}`);
            }
        }
    }
    exportResults.manifest = JSON.parse(JSON.stringify(manifest));
    if (overviewPageConfig && Object.keys(overviewPageConfig).length !== 0) {
        transferManifestEntriesOVP(overviewPage, exportResults.manifest, exportResults, jsonSchema, jsonSchema, factory, []);
    }
    return exportResults;
};
/**
 * Exports a Fiori Element V2 application.
 * It converts the entries of the input application (config file) to corresponding manifest settings and flex changes
 * @param application - content of the config file of an application
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
const exportApplicationV2 = (application, manifest, jsonSchema) => {
    const exportResults = getDefaultExportResult();
    exportResults.manifest = JSON.parse(JSON.stringify(manifest));
    //transfer application settings
    const applicationV2 = Object.assign(new application_1.ApplicationV2(), application);
    applicationV2.settings = Object.assign(new application_1.AppSettings(), application['settings']);
    for (const key in jsonSchema['definitions']['AppSettings']['properties']) {
        const syncRule = common_1.getReflectMetadata(applicationV2.settings, key);
        if (syncRule && syncRule.manifest) {
            const path = syncRule.manifest.path();
            const manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, path);
            if (application['settings'] && application['settings'][key] !== undefined) {
                manifestSection[key] = application['settings'][key];
            }
            else {
                delete manifestSection[key];
            }
        }
    }
    // transfer pages and routings
    const manifestPages = exportResults.manifest[v2_1.ManifestSection.generic] && exportResults.manifest[v2_1.ManifestSection.generic].pages;
    if (manifestPages && application['pages']) {
        manifest_1.transformPageToNewManifestV2(application.home, application['pages'], Object.values(manifestPages)[0]);
    }
    return exportResults;
};
/**
 * Exports a Fiori Element V2 page.
 * It converts the entries of the input page (config file) to corresponding manifest settings and flex changes
 * @param appId - application id
 * @param page - content of the config file of a page
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @param entityAnnotations - list of annotations of the entity type that the page is referring to
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
function exportPageV2(exportParametersV2, ui5Version) {
    if (exportParametersV2[v2_1.SchemaType.ListReport]) {
        const { appId, page, manifest, jsonSchema, fragments, logger } = exportParametersV2[v2_1.SchemaType.ListReport];
        return exportListReportPage(appId, page, manifest, jsonSchema, ui5Version, fragments, logger);
    }
    else if (exportParametersV2[v2_1.SchemaType.ObjectPage]) {
        const { appId, page, manifest, jsonSchema, fragments, logger } = exportParametersV2[v2_1.SchemaType.ObjectPage];
        return exportObjectPage(appId, page, manifest, jsonSchema, ui5Version, fragments, logger);
    }
    else if (exportParametersV2[v2_1.SchemaType.OverviewPage]) {
        const { page, manifest, jsonSchema } = exportParametersV2[v2_1.SchemaType.OverviewPage];
        return exportOverviewPage(page.config, manifest, jsonSchema);
    }
    else if (exportParametersV2[v2_1.SchemaType.Application]) {
        const { application, manifest, jsonSchema } = exportParametersV2[v2_1.SchemaType.Application];
        return exportApplicationV2(application, manifest, jsonSchema);
    }
    else if (exportParametersV2[v2_1.SchemaType.AnalyticalListPage]) {
        const { appId, page, manifest, jsonSchema, fragments, logger } = exportParametersV2[v2_1.SchemaType.AnalyticalListPage];
        return exportAnalyticalListPage(appId, page, manifest, jsonSchema, ui5Version, fragments, logger);
    }
}
exports.exportPageV2 = exportPageV2;
//# sourceMappingURL=export.js.map