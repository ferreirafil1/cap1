"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const appProvider_1 = require("../../../common/appProvider");
const application_1 = require("../../application");
const common_1 = require("../../../common");
const listReport_1 = require("../pages/listReport");
const objectPage_1 = require("../pages/objectPage");
const analyticalListPage_1 = require("../pages/analyticalListPage");
const v4_1 = require("../../../../specification/v4");
const common_2 = require("../../../../specification/common");
const utils_1 = require("../utils");
const common_3 = require("../../../common");
const schemaAccess_1 = require("../../../../specification/schemaAccess");
var Constants;
(function (Constants) {
    Constants["OptionalQuery"] = ":?query:";
    Constants["Component"] = "sap/fe/AppComponent";
    Constants["Namespace"] = "sap.fe.templates";
})(Constants = exports.Constants || (exports.Constants = {}));
// Store controller names which should be handled latelly
const unhandledControllers = [];
// Store route associations
let associations = {};
/**
 * Sort in following way
 * 1. string targets first
 * 2. Then sort targets as array by elements count - from lowest to highest(ASC)
 * @param {SapUi5RoutingRoute} route1 - First instance of router to compare.
 * @param {SapUi5RoutingRoute} route2 - Second instance of router to compare.
 * @return {number} Compare result.
 */
function routesSorter(route1, route2) {
    const target1 = route1.target;
    const target2 = route2.target;
    const isT1Array = Array.isArray(target1);
    const isT2Array = Array.isArray(target2);
    if (isT1Array && isT2Array) {
        return target1.length - target2.length;
    }
    if (!isT1Array && !isT2Array) {
        return 0;
    }
    return !isT1Array ? -1 : 1;
}
/**
 * Method to resolve target and return target name as string.
 * Thing is that we can receive target as array of targets and we need detect which target is unique target in that array.
 * @param {SapUi5RoutingRouteTarget} target - Target to resolve.
 * @param {Array<string>} usedTargets - Array of resolved targets(which means that those targets are not unique anymore).
 * @return {string} Resolved unique target namet.
 */
function resolveTarget(target, usedTargets = []) {
    if (!Array.isArray(target)) {
        return target;
    }
    let targetParts = target;
    for (const usedTarget of usedTargets) {
        targetParts = targetParts.filter((targetPart) => !usedTarget.includes(targetPart));
    }
    return targetParts[0];
}
/**
 * Method which populates object with routings routes associations.
 * @param {SapUi5RoutingRoute} routes - Routing routes.
 * @return {object} Map object of association routes.
 */
function populateAssociations(routes) {
    const associations = {};
    routes = routes.concat().sort(routesSorter);
    const resolvedTargets = [];
    for (const route of routes) {
        const parts = route.pattern.split(':')[0].split('/');
        let target;
        if (Array.isArray(route.target)) {
            target = resolveTarget(route.target, resolvedTargets);
            resolvedTargets.push(route.target);
        }
        else {
            target = route.target;
        }
        for (const part of parts) {
            const prop = part.split('(')[0];
            associations[target] = associations[target] ? `${associations[target]}.${prop}` : prop;
        }
    }
    return associations;
}
/**
 * Determines the Pages(app.json) using routing configuration from manifest and creates the configuration for each page
 * @param manifest - manifest.json of the app
 * @param schemas - list of JSON schemas of all pages
 */
function getPagesAndConfigs(manifest, schemas, logger) {
    var _a, _b, _c, _d;
    const pages = {};
    const routing = manifest[v4_1.ManifestSection.ui5].routing;
    associations = populateAssociations(routing.routes);
    for (const id in routing.targets) {
        const target = routing.targets[id];
        const pageType = 'viewId' in target || target.name === v4_1.FE_TEMPLATE_V4_CUSTOM_PAGE
            ? common_2.PageTypeV4.CustomPage
            : target.name.endsWith(common_2.PageTypeV4.ListReport)
                ? common_2.PageTypeV4.ListReport
                : target.name.endsWith(common_2.PageTypeV4.ObjectPage)
                    ? common_2.PageTypeV4.ObjectPage
                    : target.name.endsWith(common_2.PageTypeV4.AnalyticalListPage)
                        ? common_2.PageTypeV4.AnalyticalListPage
                        : undefined;
        const page = {
            pageType: pageType
        };
        // Entity set
        if (target.options) {
            page.entitySet = target.options.settings.entitySet;
        }
        if (target.controlAggregation) {
            page.controlAggregation = target.controlAggregation;
        }
        if (associations[id] && associations[id].indexOf('.') !== -1) {
            const parts = associations[id].split('.');
            page.navigationProperty = parts[parts.length - 1];
        }
        // Custom page's view object
        if ('viewId' in target) {
            // Populate view of custom page
            page.view = {
                id: target.viewId,
                name: target.viewName
            };
        }
        else if (pageType === common_2.PageTypeV4.CustomPage) {
            page.view = Object.assign(Object.assign({}, (target.id && { id: target.id })), (((_b = (_a = target.options) === null || _a === void 0 ? void 0 : _a.settings) === null || _b === void 0 ? void 0 : _b.viewName) && {
                name: (_d = (_c = target.options) === null || _c === void 0 ? void 0 : _c.settings) === null || _d === void 0 ? void 0 : _d.viewName
            }));
        }
        // Page navigation object
        // Please note that it is moved to end as in result it would be stringified into 'json' file as last property
        if (target.options) {
            if (target.options.settings.variantManagement) {
                page.variantManagement = target.options.settings.variantManagement;
            }
            page.navigation = {};
            for (const name in target.options.settings.navigation) {
                const route = target.options.settings.navigation[name];
                page.navigation[route.detail.route] = associations[route.detail.route];
            }
            if ('viewName' in target.options.settings) {
                const viewParts = target.options.settings.viewName.split('.');
                unhandledControllers.push(viewParts[viewParts.length - 1]);
            }
        }
        else if ('viewId' in target) {
            // There no 'options' for custom page target -
            //    we need check target's controller source for navigation
            const viewParts = target.viewName.split('.');
            unhandledControllers.push(viewParts[viewParts.length - 1]);
        }
        // Get layout from route
        const route = routing.routes.find((route) => route.name === 'BookingObjectPage');
        if (route && 'layout' in route) {
            page.defaultLayoutType = route.layout;
        }
        const schemaId = common_1.generatePageId(page.pageType, page.entitySet, page.navigationProperty, target['viewId'] || (pageType === common_2.PageTypeV4.CustomPage && target['id']));
        pages[id] = page;
        if (!schemaId) {
            continue;
        }
        // Get the JSON schema for the page. If no page specific schema exists, fall back top the generic schema for the page type
        const jsonSchema = Object.keys(schemas).find((element) => element.includes(schemaId)) ||
            Object.keys(schemas).find((element) => element.includes(schemaId.slice(0, -1))) ||
            Object.keys(schemas).find((element) => element.includes(page.pageType));
        // convert settings to config
        if (jsonSchema) {
            page.config =
                page.pageType === common_2.PageTypeV4.ListReport
                    ? listReport_1.createListReportConfig(manifest, schemas[jsonSchema], logger)
                    : page.pageType === common_2.PageTypeV4.AnalyticalListPage
                        ? analyticalListPage_1.createAnalyticalListPageConfig(manifest, schemas[jsonSchema], logger)
                        : objectPage_1.createObjectPageConfig(manifest, schemas[jsonSchema], id, logger);
        }
    }
    return pages;
}
exports.getPagesAndConfigs = getPagesAndConfigs;
/**
 * Get the id of the page that is to open when the application is started.
 * @param routing UI5 routing configuration
 */
function getHome(routing) {
    for (const route of routing.routes) {
        if (route.pattern === Constants.OptionalQuery) {
            return resolveTarget(route.target);
        }
    }
    return resolveTarget(routing.routes[0].target);
}
/**
 * Method which detects app settings from manifest.
 * Currently only one setting is detected -Flexible Column Layout
 * @param routing UI5 routing configuration.
 * @return {AppSettings} Application settings.
 */
function getSettings(routing) {
    return routing.config && routing.config.flexibleColumnLayout
        ? {
            flexibleColumnLayout: routing.config.flexibleColumnLayout
        }
        : undefined;
}
class V4AppProvider extends appProvider_1.AppProvider {
    constructor(manifest, schemas) {
        // Import settings
        const appSettings = new application_1.AppSettings();
        const schemaFile = common_3.getSchemaFilePath(schemaAccess_1.SchemaType.Application);
        const appSchema = schemas[schemaFile.filename];
        utils_1.transferSettingsOfObject(appSettings, manifest, appSchema['definitions']['AppSettings'], '');
        super(manifest, schemas, getHome(manifest[v4_1.ManifestSection.ui5].routing), getPagesAndConfigs(manifest, schemas), common_2.FioriElementsVersion.v4, Object.assign(Object.assign({}, getSettings(manifest[v4_1.ManifestSection.ui5].routing)), appSettings));
        this.unhandledControllers = unhandledControllers;
    }
}
exports.V4AppProvider = V4AppProvider;
function getPages(manifest, targetName) {
    const routing = manifest[v4_1.ManifestSection.ui5].routing;
    const pages = {};
    for (const id in routing.targets) {
        const v4Page = routing.targets[id];
        if (v4Page['name'] === targetName) {
            pages[id] = v4Page;
        }
    }
    return pages;
}
exports.getPages = getPages;
//# sourceMappingURL=appProvider.js.map